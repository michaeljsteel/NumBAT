#import sys

import matplotlib.pyplot as plt
import numpy as np


import numbat
#import plotting

from plotmodes import TidyAxes
from numbattools import save_and_close_figure

class MailData:
    '''Native representation of the Gmsh mesh and node/element structures.

       Locations and numbers of elements are as generated by Gmsh before
       any scaling or removal of points by NumBAT.
    '''

    def __init__(self, lines):

        # positions of each mesh point.  This is in gmsh coords.  Sim.mesh_xy includes scaling by d_in_m
        # length self.n_msh_pts

        self.v_x = None
        self.v_y = None

        # array of 6 node lists defining each mesh element
        # length self.n_msh_elts
        self.v_elts = None

        # array of mesh point's GMsh physical type: interior surface # or physical line #
        self.v_node_physindex = None


        # arrays of centroids of element triangles
        # length self.n_msh_elts
        self.v_centx = None
        self.v_centy = None

        self._parse_lines(lines)

    def summarise_mesh(self):
        s = (f'    Initial Gmsh mesh has: {self.n_msh_pts} nodes, {self.n_msh_elts} elements. \n' \
             #f'  {len(self.v_node_physindex)} nodes \n'
             )

        #s += ' Node types:\n' + str(self.v_node_physindex)
        #s += ' Node table:\n' + str(self.v_elts)

        print(s)


    def plot_mesh(self):
        fig, axs = plt.subplots(2,2, dpi=300)

        axs = axs.flat
        cf=axs[0].scatter(self.v_x, self.v_y, s=4, c=self.v_node_physindex, cmap='Dark2')

        axs[0].set_title('Mail mesh point types', fontsize=8)



        cbar = fig.colorbar(cf, shrink=.5, pad=.025, location='right')
        cbar.set_label(label='Phys curve/surface number')


        elts = self.v_elts-1  # built for fortran indexing
        axs[1].scatter(self.v_x[elts[:,0]], self.v_y[elts[:,0]], s=6, c='red')
        axs[1].scatter(self.v_x[elts[:,1]], self.v_y[elts[:,1]], s=6, c='red')
        axs[1].scatter(self.v_x[elts[:,2]], self.v_y[elts[:,2]], s=6, c='red')
        axs[1].scatter(self.v_x[elts[:,3]], self.v_y[elts[:,3]], s=4, c='blue')
        axs[1].scatter(self.v_x[elts[:,4]], self.v_y[elts[:,4]], s=4, c='blue')
        axs[1].scatter(self.v_x[elts[:,5]], self.v_y[elts[:,5]], s=4, c='blue')

        # axs[2].scatter(self.v_x[elts[:,1]], self.v_y[elts[:,1]], s=4, c='red')
        # axs[2].scatter(self.v_x[elts[:,2]], self.v_y[elts[:,2]], s=4, c='green')
        # axs[2].scatter(self.v_x[elts[:,3]], self.v_y[elts[:,3]], s=4, c='blue')
        # axs[3].scatter(self.v_x[elts[:,4]], self.v_y[elts[:,4]], s=4, c='cyan')
        # axs[3].scatter(self.v_x[elts[:,5]], self.v_y[elts[:,5]], s=4, c='magenta')
        # axs[3].scatter(self.v_x[elts[:,6]], self.v_y[elts[:,6]], s=4, c='yellow')

        # Draw elements (solid) and sub-element (dotted) triangles
        cmap = plt.get_cmap('tab10')
        for i in range(self.n_msh_elts):
            icor = [elts[i,0],elts[i,1],elts[i,2],elts[i,0]]
            imid = [elts[i,3],elts[i,4],elts[i,5],elts[i,3]]
            ic = (2*i)%10
            axs[2].plot(self.v_x[icor], self.v_y[icor], color=cmap(ic), lw=1)
            axs[2].plot(self.v_x[imid], self.v_y[imid], ':',color=cmap(ic+1), lw=.5)

        for off in range(self.n_msh_elts):  # look for top left element
            if 10 in elts[off,:6]:
                break
        for i in range(6):
            axs[2].plot(self.v_x[elts[off, i]],self.v_y[elts[off, i]], 'o',color=cmap(i), markersize=3, label=f'Node {i}')
        axs[2].legend(loc='upper right', fontsize=8)
        axs[2].set_xlim(min(self.v_x), max(self.v_x))
        axs[2].set_ylim(min(self.v_y), max(self.v_y))

        for ax in axs:
            ax.set_xlabel(r'$x$ [μm]')
            ax.set_ylabel(r'$y$ [μm]')

        tidyaxes = TidyAxes(nax=4, props={'ax_label_fs':8, 'ax_ticklabel_fs':6,
                                     'ax_tickwidth':0.25, 'ax_linewidth':1, 'aspect':1,
                                     'cb_linewidth':1, 'cb_label_fs':10,
                                     'cb_ticklabel_fs':8, 'cb_tickwidth':0.25})


        tidyaxes.apply_to_axes(axs)
        tidyaxes.apply_to_cbars(cbar)

        pref = numbat.NumBATApp().outprefix()
        save_and_close_figure(fig, pref + '-mailmesh.png')


    def _parse_lines(self, lines):
        '''Converts mail file to an irregular grid of node centroid positions and material types.'''

        npts, nelts  = map(int, lines[0].split())
        self.n_msh_pts = npts
        self.n_msh_elts = nelts

        self.v_x = np.zeros(npts)        #
        self.v_y = np.zeros(npts)
        self.v_node_physindex = np.zeros(npts, dtype=np.int32)
        self.v_elts = np.zeros([nelts, 7], dtype=np.int32)

        self.v_centx = np.zeros(nelts)
        self.v_centy = np.zeros(nelts)

        # read mesh points
        secoff=1  # line offset in .mail file
        for i in range(npts):
            toks = lines[secoff+i].split()
            self.v_x[i] = float(toks[1])
            self.v_y[i] = float(toks[2])
            self.v_node_physindex[i] = int(toks[3])

        secoff+=npts

        # short hand for easier reading
        vx, vy = self.v_x, self.v_y

        # read mesh elements
        for i in range(nelts):
            toks = lines[secoff+i].split()
            eltnds = list(map(int, toks[1:]))  # 6 node repn of an elt and its material type

            self.v_elts[i] = eltnds

            # average of the corner points:
            # TODO: this is much less fundamental and hould be bumped somewhere secondary.
            self.v_centx[i] = (vx[eltnds[0]] + vx[eltnds[1]] + vx[eltnds[2]])/3.0
            self.v_centy[i] = (vy[eltnds[0]] + vy[eltnds[1]] + vy[eltnds[2]])/3.0

        #TODO: make an option somewhere
        plotmailmesh=True
        if plotmailmesh:
            self.summarise_mesh()
            self.plot_mesh()
