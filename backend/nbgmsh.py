
# Copyright (C) 2017-2025  Michael Steel, Bjorn Sturmberg, Kokou Dossou.

# NumBAT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import matplotlib.pyplot as plt
import numpy as np


from plotmodes import TidyAxes
from plottools import save_and_close_figure

class MailData:
    '''Native representation of the Gmsh mesh and node/element structures.

       Locations and numbers of elements are as generated by Gmsh before
       any scaling or removal of points by NumBAT.

       This doesn't have all the connectivity info that is understood by FemMesh
    '''

    def __init__(self, mesh_mail_fname):


        # read in first line giving number of msh points and elements
        with open(mesh_mail_fname) as f:
            lines= f.readlines()

        # positions of each mesh point.  This is in gmsh coords.  Sim.v_mshpt_xy includes scaling by d_in_m
        # length self.n_msh_pts

        self.v_x = None
        self.v_y = None

        # array of 6 node lists defining each mesh element
        # length self.n_msh_elts
        self.v_elts = None

        # array of mesh point's GMsh physical type: interior surface # or physical line #
        self.v_node_physindex = None


        # arrays of centroids of element triangles
        # length self.n_msh_elts
        #self.v_centx = None
        #self.v_centy = None

        self._parse_lines(lines)
        self.summarise_mesh()



    def summarise_mesh(self):
        s = (f'    initial mesh has: {self.n_msh_pts} nodes, {self.n_msh_elts} elements. \n' \
             #f'  {len(self.v_node_physindex)} nodes \n'
             )

        #s += ' Node types:\n' + str(self.v_node_physindex)
        #s += ' Node table:\n' + str(self.v_elts)

        print(s)


    def plot_mesh(self, path):
        fig, axs = plt.subplots(2,2, dpi=300)
        fig.subplots_adjust(hspace=0.3, wspace=.1)


        axs = axs.flat
        cf=axs[0].scatter(self.v_x, self.v_y, s=4, c=self.v_node_physindex, cmap='Dark2')

        axs[0].set_title('Gmsh surface and curve types', fontsize=8)

        cbar = fig.colorbar(cf, shrink=.5, pad=.025, location='right')
        cbar.set_label(label='Phys curve/surface number')


        elts = self.v_elts-1  # built for fortran indexing
        axs[1].scatter(self.v_x[elts[:,0]], self.v_y[elts[:,0]], s=6, c='red')
        axs[1].scatter(self.v_x[elts[:,1]], self.v_y[elts[:,1]], s=6, c='red')
        axs[1].scatter(self.v_x[elts[:,2]], self.v_y[elts[:,2]], s=6, c='red')
        axs[1].scatter(self.v_x[elts[:,3]], self.v_y[elts[:,3]], s=4, c='blue')
        axs[1].scatter(self.v_x[elts[:,4]], self.v_y[elts[:,4]], s=4, c='blue')
        axs[1].scatter(self.v_x[elts[:,5]], self.v_y[elts[:,5]], s=4, c='blue')

        axs[1].set_title('Vertex and edge nodes', fontsize=8)

        # axs[2].scatter(self.v_x[elts[:,1]], self.v_y[elts[:,1]], s=4, c='red')
        # axs[2].scatter(self.v_x[elts[:,2]], self.v_y[elts[:,2]], s=4, c='green')
        # axs[2].scatter(self.v_x[elts[:,3]], self.v_y[elts[:,3]], s=4, c='blue')
        # axs[3].scatter(self.v_x[elts[:,4]], self.v_y[elts[:,4]], s=4, c='cyan')
        # axs[3].scatter(self.v_x[elts[:,5]], self.v_y[elts[:,5]], s=4, c='magenta')
        # axs[3].scatter(self.v_x[elts[:,6]], self.v_y[elts[:,6]], s=4, c='yellow')

        # Draw elements (solid) and sub-element (dotted) triangles
        cmap = plt.get_cmap('tab10')
        for i in range(self.n_msh_elts):
            icor = [elts[i,0],elts[i,1],elts[i,2],elts[i,0]]
            imid = [elts[i,3],elts[i,4],elts[i,5],elts[i,3]]
            ic = (2*i)%10
            axs[2].plot(self.v_x[icor], self.v_y[icor], color=cmap(ic), lw=1)
            axs[2].plot(self.v_x[imid], self.v_y[imid], ':',color=cmap(ic+1), lw=.5)

        for off in range(self.n_msh_elts):  # look for top left element
            if 10 in elts[off,:6]:
                break
        for i in range(6):
            axs[2].plot(self.v_x[elts[off, i]],self.v_y[elts[off, i]], 'o',color=cmap(i), markersize=3, label=f'Node {i}')
        axs[2].legend(loc='upper right', fontsize=8)
        axs[2].set_xlim(min(self.v_x), max(self.v_x))
        axs[2].set_ylim(min(self.v_y), max(self.v_y))
        axs[2].set_title('NumBAT FEM sub-elements', fontsize=8)

        for ax in axs:
            ax.set_xlabel(r'$x$ [μm]')
            ax.set_ylabel(r'$y$ [μm]')

        tidyaxes = TidyAxes(nax=4, props={'ax_label_fs':8, 'ax_ticklabel_fs':6,
                                     'ax_tickwidth':0.25, 'ax_linewidth':1, 'aspect':1,
                                     'cb_linewidth':1, 'cb_label_fs':10,
                                     'cb_ticklabel_fs':8, 'cb_tickwidth':0.25})


        tidyaxes.apply_to_axes(axs)
        tidyaxes.apply_to_cbars(cbar)

        save_and_close_figure(fig, str(path) + '-mailmesh.png')


    def _parse_lines(self, lines):
        '''Converts mail file to an irregular grid of node centroid positions and material types.'''

        npts, nelts  = map(int, lines[0].split())
        self.n_msh_pts = npts
        self.n_msh_elts = nelts

        self.v_x = np.zeros(npts)        #
        self.v_y = np.zeros(npts)
        self.v_node_physindex = np.zeros(npts, dtype=np.int32)
        self.v_elts = np.zeros([nelts, 7], dtype=np.int32)

        self.v_elts_mat = np.zeros(nelts, dtype=np.int32)



        #self.v_centx = np.zeros(nelts)
        #self.v_centy = np.zeros(nelts)

        # read mesh points
        secoff=1  # line offset in .mail file
        for i in range(npts):
            toks = lines[secoff+i].split()
            self.v_x[i] = float(toks[1])
            self.v_y[i] = float(toks[2])
            self.v_node_physindex[i] = int(toks[3])

        secoff+=npts

        # short hand for easier reading
        vx, vy = self.v_x, self.v_y

        # read mesh elements
        for i in range(nelts):
            toks = lines[secoff+i].split()
            eltnds = list(map(int, toks[1:]))  # 6 node repn of an elt and its material type

            self.v_elts[i] = eltnds

            # average of the corner points:
            # TODO: this is much less fundamental and hould be bumped somewhere secondary.
            # Seems unused
            #self.v_centx[i] = (vx[eltnds[0]] + vx[eltnds[1]] + vx[eltnds[2]])/3.0
            #self.v_centy[i] = (vy[eltnds[0]] + vy[eltnds[1]] + vy[eltnds[2]])/3.0

        self.v_elts_mat = self.v_elts[:,-1]
