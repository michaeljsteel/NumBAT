# This code generated by Google gemini from prompt
# I'm looking for python code for robust root bracketing of a dispersion relation that can identify likely spurious brackets. For example where a function blows up and changes sign at some point."

import numpy as np
import matplotlib.pyplot as plt

def robust_bracket_roots(func, x_min, x_max, num_points=1000, threshold_factor=100,
                         min_abs_value_for_sign_change=1e-6,
                         ignore_large_jumps=True):
    """
    Robustly brackets roots of a function, attempting to identify and
    flag potential spurious brackets due to singularities.

    Args:
        func (callable): The function for which to find roots.
                         Should take a single float argument and return a float.
        x_min (float): The lower bound of the search interval.
        x_max (float): The upper bound of the search interval.
        num_points (int): Number of points to sample within the interval
                          to detect sign changes. A higher number increases
                          resolution but also computation time.
        threshold_factor (float): A multiplier for detecting large jumps/singularities.
                                  If the absolute value of the function changes by
                                  more than this factor between adjacent points,
                                  it's considered a potential singularity.
                                  Adjust based on the expected scale of your function.
        min_abs_value_for_sign_change (float): Minimum absolute value of f(x)
                                               for a sign change to be considered
                                               valid. Helps avoid false positives
                                               from very small values near zero
                                               or numerical noise.
        ignore_large_jumps (bool): If True, brackets identified across large
                                   jumps (potential singularities) will be flagged
                                   as spurious and not included in the 'roots' list.
                                   They will be in 'spurious_brackets'.

    Returns:
        tuple: A tuple containing two lists:
               - roots (list of tuples): Each tuple (a, b) represents an interval
                 [a, b] where a root is likely to exist.
               - spurious_brackets (list of tuples): Each tuple (a, b) represents
                 an interval [a, b] where a sign change was detected, but
                 it's likely due to a singularity.
    """

    if x_min >= x_max:
        raise ValueError("x_min must be less than x_max")
    if num_points < 2:
        raise ValueError("num_points must be at least 2")

    # Generate evenly spaced points within the interval
    x_values = np.linspace(x_min, x_max, num_points)

    # Evaluate the function at each point
    # Use a try-except block to gracefully handle potential errors during function evaluation
    # that might arise from domain issues (e.g., sqrt of negative numbers)
    y_values = np.zeros_like(x_values)
    for i, x in enumerate(x_values):
        try:
            y_values[i] = func(x)
        except Exception:
            y_values[i] = np.nan # Mark as NaN if evaluation fails

    roots = []
    spurious_brackets = []

    # Iterate through adjacent pairs of points to find sign changes
    for i in range(num_points - 1):
        x1, y1 = x_values[i], y_values[i]
        x2, y2 = x_values[i+1], y_values[i+1]

        # Skip if either y-value is NaN (indicating a point where the function is undefined)
        if np.isnan(y1) or np.isnan(y2):
            continue

        # Check for a change in sign
        # np.sign returns 0 for 0, 1 for positive, -1 for negative
        if np.sign(y1) != np.sign(y2):
            # Ensure both values are sufficiently far from zero to be a valid sign change
            # and not just numerical noise around zero.
            if abs(y1) > min_abs_value_for_sign_change and \
               abs(y2) > min_abs_value_for_sign_change:

                is_large_jump = False
                # Check for large jump characteristic of a singularity
                # This handles cases where one value is very large and the other is small,
                # or both are very large with opposite signs.
                if y1 != 0 and y2 != 0: # Avoid division by zero
                    if abs(y1 / y2) > threshold_factor or abs(y2 / y1) > threshold_factor:
                        is_large_jump = True
                # Also consider cases where one value is small and the other is extremely large
                # (e.g., approaching infinity from a finite value)
                elif (abs(y1) > min_abs_value_for_sign_change and abs(y2) > threshold_factor * abs(y1)) or \
                     (abs(y2) > min_abs_value_for_sign_change and abs(y1) > threshold_factor * abs(y2)):
                    is_large_jump = True
                # Explicitly check for infinity values if the function can return them
                if np.isinf(y1) or np.isinf(y2):
                    is_large_jump = True

                if is_large_jump:
                    # If a large jump is detected, it's likely a spurious bracket due to a singularity
                    spurious_brackets.append((x1, x2))
                    if not ignore_large_jumps:
                        # Optionally, include it in roots but tag it
                        roots.append((x1, x2, "spurious_singularity"))
                else:
                    # Otherwise, it's considered a valid root bracket
                    roots.append((x1, x2))
            else:
                # If one or both values are very close to zero, it's likely a root or a very shallow crossing.
                # We include these as potential root brackets.
                roots.append((x1, x2))

    return roots, spurious_brackets

# # --- Example Usage with various functions ---

# # Example 1: Simple function with a root (x=2, x=-2)
# def func_simple(x):
#     return x**2 - 4

# # Example 2: Function with a singularity at x=0 and a root at x=2
# def func_with_singularity(x):
#     if abs(x) < 1e-9: # Handle x very close to zero as a singularity
#         return np.inf * np.sign(x) # Blows up to +inf or -inf depending on sign
#     return 1/x - 0.5

# # Example 3: A more complex dispersion-like relation with poles and roots
# # f(omega) = (omega - 1) / (omega^2 - 4) + omega
# # Roots: omega = 1 (numerator zero), also where the whole expression is zero.
# # Poles: omega = 2, omega = -2 (denominator zero)
# def dispersion_relation_example(omega):
#     # Explicitly handle poles by returning NaN or Inf
#     if abs(omega - 2) < 1e-9:
#         return np.nan # Or np.inf * np.sign(omega - 2) for directional infinity
#     if abs(omega + 2) < 1e-9:
#         return np.nan # Or np.inf * np.sign(omega + 2)

#     # Calculate the function value
#     val = (omega - 1) / (omega**2 - 4) + omega
#     return val

# # Helper function to plot results
# def plot_function_and_brackets(func, x_min, x_max, num_points_plot, roots, spurious_brackets, title):
#     # Use more points for plotting to get a smoother curve
#     x_plot = np.linspace(x_min, x_max, num_points_plot * 5)
#     y_plot = np.array([func(x) for x in x_plot])

#     plt.figure(figsize=(10, 6))
#     plt.plot(x_plot, y_plot, label='f(x)', color='blue')
#     plt.axhline(0, color='gray', linestyle='--', linewidth=0.8, label='Zero Line')

#     # Plot root brackets
#     for r_start, r_end in roots:
#         # Check if it's a tagged spurious singularity
#         if isinstance(r_end, str) and r_end == "spurious_singularity":
#             plt.axvspan(r_start, r_start, color='red', alpha=0.3, label='Spurious Singularity' if 'Spurious Singularity' not in plt.gca().get_legend_handles_labels()[1] else "", linestyle=':', linewidth=2)
#         else:
#             plt.axvspan(r_start, r_end, color='green', alpha=0.3, label='Root Bracket' if 'Root Bracket' not in plt.gca().get_legend_handles_labels()[1] else "")

#     # Plot spurious brackets
#     for s_start, s_end in spurious_brackets:
#         plt.axvspan(s_start, s_end, color='orange', alpha=0.3, label='Spurious Bracket (Singularity)' if 'Spurious Bracket (Singularity)' not in plt.gca().get_legend_handles_labels()[1] else "")

#     plt.title(title)
#     plt.xlabel('x')
#     plt.ylabel('f(x)')
#     plt.grid(True, linestyle='--', alpha=0.7)
#     plt.legend()
#     plt.ylim(ymin=np.nanmin(y_plot[np.isfinite(y_plot)]) - 5,
#              ymax=np.nanmax(y_plot[np.isfinite(y_plot)]) + 5) # Adjust y-limits dynamically, avoiding NaNs/Infs
#     plt.show()


# # --- Run Examples ---

# print("--- Example 1: Simple Function (x^2 - 4) ---")
# roots1, spurious1 = robust_bracket_roots(func_simple, -5, 5, num_points=100)
# print(f"Detected roots: {roots1}")
# print(f"Spurious brackets: {spurious1}\n")
# plot_function_and_brackets(func_simple, -5, 5, 100, roots1, spurious1, "Function: x^2 - 4")


# print("--- Example 2: Function with a Singularity (1/x - 0.5) ---")
# # Try a range that includes the singularity at x=0
# roots2, spurious2 = robust_bracket_roots(func_with_singularity, -2, 2, num_points=200, threshold_factor=500)
# print(f"Detected roots: {roots2}")
# print(f"Spurious brackets: {spurious2}\n")
# plot_function_and_brackets(func_with_singularity, -2, 2, 200, roots2, spurious2, "Function: 1/x - 0.5")

# # Focus on the singularity
# roots2_sing, spurious2_sing = robust_bracket_roots(func_with_singularity, -0.1, 0.1, num_points=100, threshold_factor=1000)
# print(f"Detected roots (around singularity): {roots2_sing}")
# print(f"Spurious brackets (around singularity): {spurious2_sing}\n")
# plot_function_and_brackets(func_with_singularity, -0.1, 0.1, 100, roots2_sing, spurious2_sing, "Function: 1/x - 0.5 (around singularity)")


# print("--- Example 3: Dispersion Relation Example ((omega - 1) / (omega^2 - 4) + omega) ---")
# # Try a wider range to catch multiple features (poles at -2, 2; root near 1)
# roots3, spurious3 = robust_bracket_roots(dispersion_relation_example, -3, 3, num_points=500, threshold_factor=1000)
# print(f"Detected roots for DR: {roots3}")
# print(f"Spurious brackets for DR: {spurious3}\n")
# plot_function_and_brackets(dispersion_relation_example, -3, 3, 500, roots3, spurious3,
#                            "Dispersion Relation Example: (omega - 1) / (omega^2 - 4) + omega")

# # Detailed look around a pole, e.g., at omega=2
# roots3_pole, spurious3_pole = robust_bracket_roots(dispersion_relation_example, 1.9, 2.1, num_points=100, threshold_factor=10000)
# print(f"Detected roots for DR (around pole at 2): {roots3_pole}")
# print(f"Spurious brackets for DR (around pole at 2): {spurious3_pole}\n")
# plot_function_and_brackets(dispersion_relation_example, 1.9, 2.1, 100, roots3_pole, spurious3_pole,
#                            "Dispersion Relation Example (around pole at 2)")
