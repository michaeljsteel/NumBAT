%!PS-Adobe-3.0
%%Title: py_calc_modes.f
%%For: Michael Steel
%%Creator: a2ps version 4.15.5
%%CreationDate: Mon Jun  3 18:19:05 2024
%%BoundingBox: 24 24 571 818
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 8
%%PageOrder: Ascend
%%DocumentMedia: a4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black Blue Green Red 
%%DocumentSuppliedResources: procset a2ps-color-prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988-2017 Free Software Foundation, Inc.
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  0 setgray
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.5 0.5 1 setrgbcolor
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    1 setgray
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def
%%BeginResource: procset a2ps-color-prolog 2.0 1

%% Definition of the color faces.
/p {
  0 0 0 FG
  false BG
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  0 0 0 FG
  false BG
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false BG
  false UL
  false BX
  0 0 0.9 FG
  fCourier bfs scalefont setfont
  Show
} bind def

/K {
  false BG
  false UL
  false BX
  0 0 0.8 FG
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false BG
  false UL
  false BX
  0.8 0 0 FG
  fCourier bfs scalefont setfont
  Show
} bind def

/C {
  false BG
  false UL
  false BX
  0.8 0 0 FG
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/l {
  0 0 0 FG
  0.8 0.8 0 true BG
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/L {
  0 0 0 FG
  1 1 0 true BG
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/str {
  false BG
  false UL
  false BX
  0 0.5 0 FG
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  1 0 0 true BG
  false UL
  true BX
  1 1 1 FG
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul 2 div neg 0 rmoveto
    f# setfont
    0.8 0.1 0.1 FG
    c-show
  grestore
} bind def
%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 595 def
/sw 842 def
/llx 24 def
/urx 818 def
/ury 571 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 8.005733 def
/cw 4.803440 def

% Dictionary for ISO-8859-1 support
/iso1dict 6 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   501.959430 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#) p
(include) K
( ") p
(numbat_decl.h) str
(") p n
() N
(C-------------------------------------------------------------------------------) N
(---------) N
() N
(c     subroutine prepare_workspaces\( n_msh_pts, n_msh_el, n_modes,) c n
(c    *     int_max, cmplx_max, real_max, awk, bwk, cwk, overlap_L, ) N
(c    *     iindex, errco, emsg\)) N
(c) N
(c     integer*8 int_max, cmplx_max, real_max) N
(c     integer*8 n_msh_el, n_msh_pts, n_modes) N
(c     integer :: stat=0) N
(c) N
(c     integer*8, dimension\(:\), allocatable :: awk) N
(c     complex*16, dimension\(:\), allocatable :: bwk) N
(c     double precision, dimension\(:\), allocatable :: cwk) N
(c     integer*8, dimension\(:\), allocatable :: iindex) N
(c     complex*16, dimension\(:,:\), allocatable :: overlap_L) N
(c     integer*8 errco) N
(c     character*2048 emsg) N
(c) N
(c     call array_size\(n_msh_pts, n_msh_el, n_modes,) N
(c    *     int_max, cmplx_max, real_max, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
(c) N
(c     allocate\(bwk\(cmplx_max\), STAT=stat\)) N
(c     call check_alloc\(stat, cmplx_max, "b", -1, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
(c) N
(c     allocate\(cwk\(real_max\), STAT=stat\)) N
(c     call check_alloc\(stat, real_max, "c", -1, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
(c) N
(c     allocate\(awk\(int_max\), STAT=stat\)) N
(c     call check_alloc\(stat, int_max, "a", -1, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
(c) N
(c     allocate\(overlap_L\(n_modes,n_modes\), STAT=stat\)) N
(c     call check_alloc\(stat, n_modes*n_modes, ) N
(c    *   "overlap_L", -1, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
(c) N
(c     allocate\(iindex\(n_modes\), STAT=stat\)) N
(c     call check_alloc\(stat, n_modes, "iindex", -1, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
(c) N
(c     end subroutine prepare_workspaces) N
(C-------------------------------------------------------------------------------) p n
(---------) N
() N
() N
(       ) N
(c   lambda       - free space wavelength in m) c n
(c   n_modes    - desired number of eigenvectors) N
(c   n_msh_pts    - number of FEM mesh points  ) N
(c   n_msh_el     - number of FEM \(triang\) elements) N
(c   n_typ_el     - number of types of elements \(and therefore elements\)) N
(c   v_refindex_n - array of effective index of materials) N
(c   bloch_vec    - in-plane k-vector \(normally tiny just to avoid degeneracies\)) N
(c   shift_ksqr   - k_est^2 = n^2 k_0^2  : estimate of eigenvalue k^2) N
(c   bnd_cnd_i    - bnd conditions \(Dirichlet = 0, Neumann = 1, Periodic = 2\)   ) N
(c   beta1        - array of eigenvalues kz) N
(py_calc_modes.f) (Page 1/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(c   sol1         - 4-dim array of solutions [field comp, node of element \(1..13\)) c n
(?!, eigvalue, element number] \(strange ordering\)) N
(c   mode_pol     - unknown - never used in python) N
(c   table_nod    - 2D array [node_on_elt-1..6][n_msh_el] giving the mesh point m) N
(p of each node) N
(c                  Points where type_el[mp] is not the same for all 6 nodes must) N
( be interface points ) N
(c   type_el      - n_msh_el array: material index for each element) N
(c   type_nod     - is boundary node?) N
(c   mesh_xy        - \(2 , n_msh_pts\)  x,y coords?) N
(c   ls_material  - \(1, nodes_per_el+7, n_msh_el\)) N
() p n
(      ) S
(subroutine) K
( ) p
(calc_EM_modes) L
(\() p n
(c     Inputs) c n
(     *    n_modes, lambda, dimscale_in_m, bloch_vec, shift_ksqr, ) p n
(     *    E_H_field, bnd_cdn_i, itermax, debug, ) N
(     *    mesh_file, n_msh_pts, n_msh_el, n_typ_el, v_refindex_n, ) N
(c     Outputs) c n
(     *    beta1, sol1, mode_pol,) p n
(     *    table_nod, type_el, type_nod, mesh_xy, ls_material,) N
(     *    errco, emsg\)) N
() N
(C************************************************************************) c n
(C) N
(C  Program:) N
(C     FEM solver of Electromagnetic waveguide problems.) N
(C     This subroutine is compiled by f2py & called in mode_calcs.py) N
(C) N
(C  Authors:) N
(C    Bjorn Sturmberg & Kokou B. Dossou) N
(C) N
(C************************************************************************) N
(C) N
(      ) p
(implicit) K
( ) p
(none) K n
() p n
(C  Local parameters:) c n
(      ) p
(integer) K
(*8 int_max, cmplx_max, int_used, cmplx_used) p n
(      ) S
(integer) K
(*8 real_max, real_used) p n
(C      parameter \(int_max=2**22, cmplx_max=2**26\)) c n
(C      parameter \(real_max=2**21\)) N
(C     !   a\(int_max\)) N
(      ) p
(integer) K
(*8, ) p
(dimension) K
(\(:\), ) p
(allocatable) K
( :: awk) p n
(C     !  b\(cmplx_max\)) c n
(      ) p
(complex) K
(*16, ) p
(dimension) K
(\(:\), ) p
(allocatable) K
( :: bwk) p n
(C     !  c\(real_max\)) c n
(      ) p
(double precision) K
(, ) p
(dimension) K
(\(:\), ) p
(allocatable) K
( :: cwk) p n
(      ) S
(integer) K
( :: stat=0) p n
(      ) S
(integer) K
(*8 errco) p n
(      ) S
(character) K
(*2048 emsg) p n
(C) c n
(C  Declare the pointers of the integer super-vector) N
(      ) p
(integer) K
(*8 ip_table_E, ip_table_N_E_F, ip_visite) p n
(      ) S
(integer) K
(*8 ip_type_N_E_F, ip_eq) p n
(      ) S
(integer) K
(*8 ip_period_N, ip_nperiod_N) p n
(      ) S
(integer) K
(*8 ip_period_N_E_F, ip_nperiod_N_E_F) p n
(C      integer*8 ip_col_ptr, ip_bandw) c n
(C  Declare the pointers of the real super-vector) N
(      ) p
(integer) K
(*8 jp_x_N_E_F) p n
(C      integer*8 jp_matD, jp_matL, jp_matU) c n
(C      integer*8 jp_matD2, jp_matL2, jp_matU2) N
(      ) p
(integer) K
(*8 jp_vect1, jp_vect2, jp_workd, jp_resid, jp_vschur) p n
(      ) S
(integer) K
(*8 jp_trav, jp_vp) p n
(py_calc_modes.f) (Page 2/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (1/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(integer) K
(*8 n_typ_el) p n
(      ) S
(complex) K
(*16 pp\(n_typ_el\), qq\(n_typ_el\)) p n
(      ) S
(complex) K
(*16 eps_eff\(n_typ_el\), v_refindex_n\(n_typ_el\)) p n
(c     bnd_cdn_i = 0 => Dirichlet boundary condition) c n
(c     bnd_cdn_i = 1 => Neumann boundary condition) N
(c     bnd_cdn_i = 2 => Periodic boundary condition) N
(      ) p
(integer) K
(*8 n_msh_el, n_msh_pts, nodes_per_el, ui, bnd_cdn_i) p n
(C     ! Number of nodes per element) c n
(      ) p
(parameter) K
(\(nodes_per_el=6\)) p n
() N
(      ) S
(! type_nod: interior \(=0\) or boundary \(!=0\) point?) c n
(      ) p
(! type_el:  material index of element) c n
(      ) p
(integer) K
(*8 type_nod\(n_msh_pts\), type_el\(n_msh_el\)) p n
() N
() N
(      ) S
(integer) K
(*8 table_nod\(nodes_per_el, n_msh_el\)) p n
(      ) N
(C, len_skyl, nsym) N
(c     E_H_field = 1 => Electric field formulation \(E-Field\)) c n
(c     E_H_field = 2 => Magnetic field formulation \(H-Field\)) N
(      ) p
(integer) K
(*8 E_H_field) p n
(      ) S
(integer) K
(*8 neq, debug) p n
(      ) S
(integer) K
(*8 n_msh_pts_p3) p n
() N
(C  Variable used by valpr) c n
(      ) p
(integer) K
(*8 n_modes, nvect, itermax, ltrav) p n
(      ) S
(integer) K
(*8 n_conv, i_base) p n
(      ) S
(double precision) K
( ls_data\(10\)) p n
(c      integer*8 pointer_int\(20\), pointer_cmplx\(20\)) c n
(C      integer*8 iindex\(2000\), n_core\(2\)) N
(      ) p
(integer) K
(*8, ) p
(dimension) K
(\(:\), ) p
(allocatable) K
( :: iindex) p n
(      ) S
(integer) K
(*8 n_core\(2\)) p n
(      ) S
(complex) K
(*16 z_beta, z_tmp, z_tmp0) p n
(      ) S
(integer) K
(*8 n_edge, n_face, n_ddl, n_ddl_max, n_k) p n
(c     variable used by UMFPACK) c n
(      ) p
(double precision) K
( control \(20\), info_umf \(90\)) p n
(      ) S
(integer) K
(*8 numeric) p n
(C  Renumbering) c n
(c      integer*8 ip_row_ptr, ip_bandw_1, ip_adjncy) N
(c      integer*8 len_adj, len_adj_max, len_0_adj_max) N
(c, iout, nonz_1, nonz_2) p n
(      ) S
(integer) K
(*8 i, j) p n
(      ) S
(integer) K
(*8 ival, iel, inod) p n
(c     Wavelength lambda in units of m) c n
(      ) p
(double precision) K
( lambda, dimscale_in_m) p n
(      ) S
(double precision) K
( freq, lat_vecs\(2,2\), tol) p n
(      ) S
(double precision) K
( k_0, pi, dim_x, dim_y) p n
(      ) S
(double precision) K
( bloch_vec\(2\), bloch_vec_k\(2\)) p n
(      ) S
(complex) K
(*16 shift_ksqr) p n
(C  Timing variables) c n
(      ) p
(double precision) K
( time1, time2) p n
(      ) S
(double precision) K
( stime1, stime2) p n
(      ) S
(double precision) K
( time1_fact, time2_fact) p n
(C     double precision time1_asmbl, time2_asmbl) c n
(      ) p
(double precision) K
( time1_postp) p n
(      ) S
(double precision) K
( stime1_postp) p n
(      ) S
(double precision) K
( time1_arpack, time2_arpack) p n
(      ) S
(double precision) K
( time1_J, time2_J) p n
(      ) S
(double precision) K
( stime1_J, stime2_J) p n
(C     character*\(8\) start_date, end_date) c n
(      ) p
(character) K
(*\(10\) start_time, end_time) p n
(C  Names and Controls) c n
(py_calc_modes.f) (Page 3/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(character) K
( mesh_file*1000, gmsh_file*1000, log_file*1000) p n
(      ) S
(character) K
( gmsh_file_pos*1000) p n
(      ) S
(character) K
( overlap_file*1000, dir_name*1000, msg*20) p n
(      ) S
(character) K
(*1000 tchar) p n
(      ) S
(integer) K
(*8 namelength, PrintAll) p n
(      ) S
(integer) K
(*8 plot_modes) p n
(      ) S
(integer) K
(*8 pair_warning, homogeneous_check) p n
(      ) S
(integer) K
(*8 q_average, plot_real, plot_imag, plot_abs) p n
(      ) S
(complex) K
(*16 ii) p n
() N
(c     Declare the pointers of the real super-vector) c n
(      ) p
(integer) K
(*8 kp_rhs_re, kp_rhs_im, kp_lhs_re, kp_lhs_im) p n
(      ) S
(integer) K
(*8 kp_mat1_re, kp_mat1_im) p n
() N
(c     Declare the pointers of for sparse matrix storage) c n
(      ) p
(integer) K
(*8 ip_col_ptr, ip_row) p n
(      ) S
(integer) K
(*8 jp_mat2) p n
(      ) S
(integer) K
(*8 ip_work, ip_work_sort, ip_work_sort2) p n
(      ) S
(integer) K
(*8 nonz, nonz_max, max_row_len) p n
() N
(      ) S
(integer) K
(*8 ip) p n
(      ) S
(integer) K
( i_32) p n
() N
(c     new breed of variables to prise out of awk, bwk and cwk) c n
(      ) p
(double precision) K
( mesh_xy\(2,n_msh_pts\)) p n
(      ) S
(complex) K
(*16, ) p
(target) K
( :: sol1\(3,nodes_per_el+7,n_modes,n_msh_el\)) p n
(      ) S
(complex) K
(*16, ) p
(target) K
( :: sol2\(3,nodes_per_el+7,n_modes,n_msh_el\)) p n
(      ) S
(complex) K
(*16, ) p
(pointer) K
( :: sol\(:,:,:,:\)) p n
(      ) S
(complex) K
(*16, ) p
(dimension) K
(\(:,:\), ) p
(allocatable) K
( :: overlap_L) p n
() N
(      ) S
(complex) K
(*16, ) p
(target) K
( :: beta1\(n_modes\), beta2\(n_modes\)) p n
(      ) S
(complex) K
(*16, ) p
(pointer) K
( :: beta\(:\)) p n
(      ) S
(complex) K
(*16 mode_pol\(4,n_modes\)) p n
() N
(      ) S
(complex) K
(*16 ls_material\(1,nodes_per_el+7,n_msh_el\)) p n
() N
(Cf2py ) S
(intent) K
(\() p
(in) k
(\) lambda, n_modes) p n
(Cf2py ) S
(intent) K
(\() p
(in) k
(\) debug, mesh_file, n_msh_pts, n_msh_el) p n
(Cf2py ) S
(intent) K
(\() p
(in) k
(\) v_refindex_n, bloch_vec, dimscale_in_m, shift_ksqr) p n
(Cf2py ) S
(intent) K
(\() p
(in) k
(\) E_H_field, bnd_cdn_i, itermax) p n
(Cf2py ) S
(intent) K
(\() p
(in) k
(\) plot_modes, plot_real, plot_imag, plot_abs) p n
(Cf2py ) S
(intent) K
(\() p
(in) k
(\) cmplx_max, real_max, int_max, n_typ_el) p n
() N
(Cf2py depend\(v_refindex_n\) n_typ_el) N
() N
(Cf2py ) S
(intent) K
(\() p
(out) k
(\) beta1, type_nod, ls_material) p n
(Cf2py ) S
(intent) K
(\() p
(out) k
(\) sol1, mode_pol, table_nod, type_el, mesh_xy) p n
() N
(Cf2py ) S
(intent) K
(\() p
(out) k
(\) errco) p n
(Cf2py ) S
(intent) K
(\() p
(out) k
(\) emsg) p n
() N
() N
(C      n_64 = 2) c n
(C     !n_64**28 on Vayu, **27 before) N
(C      cmplx_max=n_64**25) N
(C      real_max = n_64**23) N
(C      int_max  = n_64**22) N
(c      3*n_msh_pts+n_msh_el+nodes_per_el*n_msh_el) N
() p n
(C      write\(*,*\) "cmplx_max = ", cmplx_max) c n
(C      write\(*,*\) "real_max = ", real_max) N
(C      write\(*,*\) "int_max = ", int_max) N
(py_calc_modes.f) (Page 4/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (2/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(c     ii = sqrt\(-1\)) c n
(      ii = ) p
(cmplx) K
(\(0.0d0, 1.0d0, 8\)) p n
() N
(C     Old inputs now internal to here and commented out by default.) c n
(C      mesh_format = 1) N
(C      Checks = 0 ! check completeness, energy conservation) N
(C       ! only need to print when debugging J overlap, orthogonal) N
(      PrintAll = debug ) p n
(C       ! ARPACK accuracy \(0.0 for machine precision\)) c n
(C       lx=1.0 ! Diameter of unit cell. Default, lx = 1.0.) N
(C       ly=1.0 ! NOTE: currently requires ly=lx, ie rectangular unit cell.) N
() p n
(      tol = 0.0 ) N
() N
(      errco= 0) N
(      emsg = "") N
() N
(c     Declare work space arrays) c n
() p n
(c     call prepare_workspaces\( n_msh_pts, n_msh_el, n_modes,) c n
(c    *     int_max, cmplx_max, real_max, awk, bwk, cwk, overlap_L, ) N
(c    *     iindex, errco, emsg\)) N
(c     RETONERROR\(errco\) ) N
() p n
(      ) S
(call) K
( ) p
(array_size) l
(\(n_msh_pts, n_msh_el, n_modes,) p n
(     *     int_max, cmplx_max, real_max, errco, emsg\)) N
(      RETONERROR\(errco\) ) N
() N
(      ) S
(allocate) K
(\(bwk\(cmplx_max\), STAT=stat\)) p n
(      ) S
(call) K
( ) p
(check_alloc) l
(\(stat, cmplx_max, ") p
(b) str
(", -1, errco, emsg\)) p n
(      RETONERROR\(errco\) ) N
() N
(      ) S
(allocate) K
(\(cwk\(real_max\), STAT=stat\)) p n
(      ) S
(call) K
( ) p
(check_alloc) l
(\(stat, real_max, ") p
(c) str
(", -1, errco, emsg\)) p n
(      RETONERROR\(errco\) ) N
() N
(      ) S
(allocate) K
(\(awk\(int_max\), STAT=stat\)) p n
(      ) S
(call) K
( ) p
(check_alloc) l
(\(stat, int_max, ") p
(a) str
(", -1, errco, emsg\)) p n
(      RETONERROR\(errco\) ) N
() N
(      ) S
(allocate) K
(\(overlap_L\(n_modes,n_modes\), STAT=stat\)) p n
(      ) S
(call) K
( ) p
(check_alloc) l
(\(stat, n_modes*n_modes, ) p n
(     *   ") S
(overlap_L) str
(", -1, errco, emsg\)) p n
(      RETONERROR\(errco\) ) N
() N
(      ) S
(allocate) K
(\(iindex\(n_modes\), STAT=stat\)) p n
(      ) S
(call) K
( ) p
(check_alloc) l
(\(stat, n_modes, ") p
(iindex) str
(", -1, errco, emsg\)) p n
(      RETONERROR\(errco\) ) N
() N
() N
(CCCCCCCCCCCCCCCCC POST F2PY CCCCCCCCCCCCCCCCCCCCCCCCC) c n
() p n
(C     clean mesh_format) c n
(C     TODO: Drop these debug files?) N
(      namelength = ) p
(len_trim) K
(\(mesh_file\)) p n
(      gmsh_file = mesh_file\(1:namelength-5\)//') S
(.msh) str
(') p n
(      gmsh_file_pos = mesh_file\(1:namelength\)) N
(      log_file = mesh_file\(1:namelength-5\)//') S
(.log) str
(') p n
(      ) S
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(*,*\) ") p
(mesh_file = ) str
(", mesh_file) p n
(        ) S
(write) K
(\(*,*\) ") p
(gmsh_file = ) str
(", gmsh_file) p n
(py_calc_modes.f) (Page 5/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(endif) K n
() p n
(c     Calculate effective permittivity for each type of material) c n
(      ) p
(do) K
( i_32 = 1, ) p
(int) K
(\(n_typ_el\)) p n
(        eps_eff\(i_32\) = v_refindex_n\(i_32\)**2) N
(      ) S
(end) K
( ) p
(do) K n
() p n
(C     !ui = Unite dImpression) c n
(      ui = 6) p n
(      pi = 3.141592653589793d0) N
(C      nsym = 1 ! nsym = 0 => symmetric or hermitian matrices) c n
(C) N
() p n
(      nvect = 2*n_modes + n_modes/2 +3) N
() N
(CCCCCCCCCCCCCCCCC END POST F2PY CCCCCCCCCCCCCCCCCCCCC) c n
() p n
(C     ! initial time  in unit = sec.) c n
(      ) p
(call) K
( ) p
(get_clocks) l
(\(stime1, time1\)) p n
(C) c n
(C####################  Start FEM PRE-PROCESSING  ########################) p n
(C) c n
() p n
(      dim_x = dimscale_in_m) N
(      dim_y = dimscale_in_m) N
() N
(      ) S
(! fills table_nod and mesh_xy) c n
(      ) p
(call) K
( ) p
(geometry) l
( \(n_msh_el, n_msh_pts, nodes_per_el, n_typ_el,) p n
(     *     dim_x, dim_y, type_nod, type_el, table_nod,) N
(     *     mesh_xy, mesh_file, errco, emsg\)) N
(      RETONERROR\(errco\) ) N
() N
() N
(C) c n
(      ) p
(call) K
( ) p
(lattice_vec) l
( \(n_msh_pts, mesh_xy, lat_vecs, debug\)) p n
(C) c n
(C      V = number of vertices) N
(C      E = number of edges) N
(C      F =  number of faces) N
(C      C =  number of cells \(3D, tetrahedron\)) N
(C) N
(C     From Euler's theorem on 3D graphs: V-E+F-C = 1 - \(number of holes\)) N
(C     n_msh_pts = \(number of vertices\) + \(number of mid-edge point\) = V + E;) N
(C) N
(C     ! each element is a face) N
(      n_face = n_msh_el) p n
(      ip_table_N_E_F = 1) N
(      ) S
(call) K
( ) p
(list_face) l
( \(n_msh_el, awk\(ip_table_N_E_F\)\)) p n
() N
(C     n_ddl_max = max\(N_Vertices\) + max\(N_Edge\) + max\(N_Face\)) c n
(C     For P2 FEM n_msh_pts=N_Vertices+N_Edge) N
(C     note: each element has 1 face, 3 edges and 10 P3 nodes) N
(      n_ddl_max = n_msh_pts + n_face) p n
(      ip_visite =  ip_table_N_E_F  + 14*n_msh_el) N
(      ip_table_E = ip_visite + n_ddl_max) N
(C) c n
(      ) p
(call) K
( ) p
(list_edge) l
( \(n_msh_el, n_msh_pts, nodes_per_el, n_edge,) p n
(     *    type_nod, table_nod,) N
(     *    awk\(ip_table_E\), awk\(ip_table_N_E_F\), awk\(ip_visite\)\)) N
(      ) S
(call) K
( ) p
(list_node_P3) l
( \(n_msh_el, n_msh_pts, nodes_per_el, n_edge, ) p n
(     *    n_msh_pts_p3, table_nod, awk\(ip_table_N_E_F\), awk\(ip_visite\)\)) N
(      n_ddl = n_edge + n_face + n_msh_pts_p3) N
(py_calc_modes.f) (Page 6/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (3/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(C) c n
(      ) p
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: n_msh_pts, n_msh_el = ) str
(", ) p n
(     *     n_msh_pts, n_msh_el) N
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: n_msh_pts_p3 = ) str
(", n_msh_pts_p3) p n
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: n_vertex, n_edge, n_face,) str
(",) p n
(     *     ") S
( n_msh_el = ) str
(",) p n
(     *    \(n_msh_pts - n_edge\), n_edge, n_face, n_msh_el) N
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: 2D case of the Euler &) str n
(     & characteristic: V-E+F=1-\(number of holes\)) S
(") p n
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Euler characteristic: V - E + F &) str n
(     &= ) S
(", \(n_msh_pts - n_edge\) - n_edge + n_face) p n
(      ) S
(endif) K n
(cC) c n
(cC-----------) p n
(cC) c n
(cC     overwriting pointers ip_row_ptr, ..., ip_adjncy) N
(c) N
(      ip_type_N_E_F = ip_table_E + 4*n_edge) p n
(C) c n
(      jp_x_N_E_F = 1) p n
(      ) S
(call) K
( ) p
(type_node_edge_face) l
( \(n_msh_el, n_msh_pts, nodes_per_el, ) p n
(     *      n_ddl, type_nod, table_nod, awk\(ip_table_N_E_F\),) N
(     *      awk\(ip_visite\), awk\(ip_type_N_E_F\),) N
(     *      mesh_xy, bwk\(jp_x_N_E_F\)\)) N
(C) c n
(      ) p
(call) K
( ) p
(get_coord_p3) l
( \(n_msh_el, n_msh_pts, nodes_per_el, n_ddl,) p n
(     *      table_nod, type_nod, awk\(ip_table_N_E_F\),) N
(     *      awk\(ip_type_N_E_F\), mesh_xy, bwk\(jp_x_N_E_F\), ) N
(     *      awk\(ip_visite\)\)) N
(C) c n
(        ip_period_N = ip_type_N_E_F + 2*n_ddl) p n
(        ip_nperiod_N = ip_period_N + n_msh_pts) N
(        ip_period_N_E_F = ip_nperiod_N + n_msh_pts) N
(        ip_nperiod_N_E_F = ip_period_N_E_F + n_ddl) N
(        ip_eq = ip_nperiod_N_E_F + n_ddl) N
(C) c n
(C     Dirichlet or Neumann conditions) N
(      ) p
(if) K
( \(bnd_cdn_i ) p
(.eq.) K
( 0 ) p
(.or.) K
( bnd_cdn_i ) p
(.eq.) K
( 1\) ) p
(then) K
( ) p n
(        ) S
(call) K
( ) p
(bound_cond) l
( \(bnd_cdn_i, n_ddl, neq, awk\(ip_type_N_E_F\),) p n
(     *    awk\(ip_eq\)\)) N
() N
(C     Periodic  conditions \(never in NumBAT\)) c n
(      ) p
(elseif) K
(\(bnd_cdn_i ) p
(.eq.) K
( 2\) ) p
(then) K n
(        ) p
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(          ) p
(write) K
(\(ui,*\) ") p
(###### periodic_node) str
(") p n
(        ) S
(endif) K n
() p n
(        ) S
(call) K
( ) p
(periodic_node) l
(\(n_msh_el, n_msh_pts, nodes_per_el, type_nod,) p n
(     *      mesh_xy, awk\(ip_period_N\), awk\(ip_nperiod_N\),) N
(     *      table_nod, lat_vecs\)) N
(        ) S
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(          ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: ###### periodic_N_E_F) str
(") p n
(        ) S
(endif) K n
() p n
(        ) S
(call) K
( ) p
(periodic_N_E_F) l
( \(n_ddl, awk\(ip_type_N_E_F\),) p n
(     *      bwk\(jp_x_N_E_F\), awk\(ip_period_N_E_F\),) N
(     *      awk\(ip_nperiod_N_E_F\), lat_vecs\)) N
() N
(        ) S
(call) K
( ) p
(periodic_cond) l
( \(bnd_cdn_i, n_ddl, neq, awk\(ip_type_N_E_F\),) p n
(     *       awk\(ip_period_N_E_F\), awk\(ip_eq\), debug\)) N
() N
(py_calc_modes.f) (Page 7/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(else) K n
(C TODO: this will never happen because of python checks) c n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: bnd_cdn_i has value : ) str
(",) p n
(     *       bnd_cdn_i) N
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Aborting...) str
(") p n
(        errco = -10) N
(        ) S
(return) K
( ) p n
(      ) S
(endif) K n
(C) c n
(      ) p
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: neq, n_ddl = ) str
(", neq, n_ddl) p n
(      ) S
(endif) K n
(C) c n
(C=====calcul du vecteur de localisation des colonnes) N
(C     pour le traitement skyline de la matrice globale) N
(C     Type of sparse storage of the global matrice:) N
(C                                   Symmetric Sparse Skyline format) N
(C     Determine the pointer for the Symmetric Sparse Skyline format) N
(c) N
(c      ip_col_ptr = ip_eq + 3*n_ddl) N
(c      ip_bandw  = ip_col_ptr + neq + 1) N
(c      int_used = ip_bandw + neq + 1) N
(cC) N
(c      if \(int_max .lt. int_used\) then) N
(c        write\(ui,*\)) N
(c        write\(ui,*\) 'The size of the integer supervector is too small') N
(c        write\(ui,*\) 'integer super-vec: int_max  = ', int_max) N
(c        write\(ui,*\) 'integer super-vec: int_used = ', int_used) N
(c        write\(ui,*\) 'Aborting...') N
(c        stop) N
(c      endif) N
(C) N
(CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC) N
(c) N
(c     Sparse matrix storage) N
(c) N
(      ip_col_ptr = ip_eq + 3*n_ddl) p n
() N
(      ) S
(call) K
( ) p
(csr_max_length) l
( \(n_msh_el, n_ddl, neq, nodes_per_el,) p n
(     *  awk\(ip_table_N_E_F\), awk\(ip_eq\), awk\(ip_col_ptr\), nonz_max\)) N
(c) c n
(c      ip = ip_col_ptr + neq + 1 + nonz_max) N
(      ip = ip_col_ptr + neq + 1) p n
(      ) S
(if) K
( \(ip ) p
(.gt.) K
( int_max\) ) p
(then) K n
(         ) p
(write) K
(\(emsg,*\) ") p
(py_calc_modes.f: ip > int_max : ) str
(",) p n
(     *    ip, int_max, ") S
(py_calc_modes.f: nonz_max = ) str
(", nonz_max,) p n
(     *   ") S
(py_calc_modes.f: increase the size of int_max) str
(") p n
(        errco = -11) N
(        ) S
(return) K
( ) p n
(      ) S
(endif) K n
(c) c n
(      ip_row = ip_col_ptr + neq + 1) p n
() N
(      ) S
(call) K
( ) p
(csr_length) l
( \(n_msh_el, n_ddl, neq, nodes_per_el, ) p n
(     *   awk\(ip_table_N_E_F\), awk\(ip_eq\), awk\(ip_row\), awk\(ip_col_ptr\), ) N
(     *  nonz_max, nonz, max_row_len, ip, int_max, debug\)) N
() N
(      ip_work = ip_row + nonz) N
(      ip_work_sort = ip_work + 3*n_ddl) N
(      ip_work_sort2 = ip_work_sort + max_row_len) N
() N
(c     sorting csr ...) c n
(py_calc_modes.f) (Page 8/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (4/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(call) K
( ) p
(sort_csr) l
( \(neq, nonz, max_row_len, awk\(ip_row\),) p n
(     *  awk\(ip_col_ptr\), awk\(ip_work_sort\), awk\(ip_work\),) N
(     *  awk\(ip_work_sort2\)\)) N
() N
(      ) S
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: nonz_max = ) str
(", nonz_max) p n
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: nonz = ) str
(", nonz) p n
(        ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: cmplx_max/nonz = ) str
(",) p n
(     *    ) S
(dble) K
(\(cmplx_max\)/) p
(dble) K
(\(nonz\)) p n
(      ) S
(endif) K n
() p n
(      int_used = ip_work_sort2 + max_row_len) N
() N
(      ) S
(if) K
( \(int_max ) p
(.lt.) K
( int_used\) ) p
(then) K n
(        ) p
(write) K
(\(emsg,*\)') p
(The size of the integer supervector is too small) str
(',) p n
(     *   ') S
(integer super-vec: int_max  = ) str
(', int_max,) p n
(     *   ') S
(integer super-vec: int_used = ) str
(', int_used) p n
(        errco = -12) N
(        ) S
(return) K
( ) p n
(      ) S
(endif) K n
(c) c n
(cccccccccccccccccccccccccccccccccccccccccccccccccc) N
(c) N
(cC) N
(      jp_mat2 = jp_x_N_E_F + 3*n_ddl) p n
() N
(      jp_vect1 = jp_mat2 + nonz) N
(      jp_vect2 = jp_vect1 + neq) N
(      jp_workd = jp_vect2 + neq) N
(      jp_resid = jp_workd + 3*neq) N
() N
(C     ! Eigenvectors) c n
(      jp_vschur = jp_resid + neq) p n
(      jp_trav = jp_vschur + neq*nvect) N
() N
(      ltrav = 3*nvect*\(nvect+2\)) N
(      jp_vp = jp_trav + ltrav) N
() N
(      cmplx_used = jp_vp + neq*n_modes) N
(C) c n
(      ) p
(if) K
( \(cmplx_max ) p
(.lt.) K
( cmplx_used\)  ) p
(then) K n
(        ) p
(write) K
(\(emsg,*\)') p
(The size of the complex supervector is too small) str
(',) p n
(     *   ') S
(complex super-vec: int_max  = ) str
(', cmplx_max,) p n
(     *   ') S
(complex super-vec: int_used = ) str
(', cmplx_used) p n
(        errco = -13) N
(        ) S
(return) K
( ) p n
(      ) S
(endif) K n
(c) c n
(      kp_rhs_re = 1) p n
(      kp_rhs_im = kp_rhs_re + neq) N
(      kp_lhs_re = kp_rhs_im + neq) N
(      kp_lhs_im = kp_lhs_re + neq) N
(      kp_mat1_re = kp_lhs_im + neq) N
(      kp_mat1_im = kp_mat1_re + nonz) N
(      real_used = kp_mat1_im + nonz) N
() N
(      ) S
(if) K
( \(real_max ) p
(.lt.) K
( real_used\) ) p
(then) K n
(        ) p
(write) K
(\(emsg,*\) ') p
(The size of the real supervector is too small) str
(',) p n
(     *  ') S
(2*nonz  = ) str
(', 2*nonz,) p n
(     *  ') S
(real super-vec: real_max  = ) str
(', real_max,) p n
(     *  ') S
(real super-vec: real_used = ) str
(', real_used) p n
(        errco = -14) N
(py_calc_modes.f) (Page 9/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(return) K
( ) p n
(      ) S
(endif) K n
(c) c n
(c) N
(c###############################################) p n
(c) c n
(c       ----------------------------------------------------------------) N
(c       convert from 1-based to 0-based) N
(c       ----------------------------------------------------------------) N
(c) N
(      ) p
(do) K
( j = 1, neq+1) p n
(          awk\(j+ip_col_ptr-1\) = awk\(j+ip_col_ptr-1\) - 1) N
(      ) S
(end) K
( ) p
(do) K n
(      ) p
(do) K
(  j = 1, nonz) p n
(          awk\(j+ip_row-1\) = awk\(j+ip_row-1\) - 1) N
(      ) S
(end) K
( ) p
(do) K n
(c) c n
(c) N
(c     The CSC indexing, i.e., ip_col_ptr, is 1-based) N
(c       \(but valpr.f will change the CSC indexing to 0-based indexing\)) N
(      i_base = 0) p n
(c) c n
(C) N
(C#####################  ) p
(End) K
( FEM PRE-PROCESSING  #########################) p n
(C) c n
(C) N
(C) N
(      ) p
(write) K
(\(ui,*\)) p n
(      ) S
(write) K
(\(ui,*\) ") p
(-----------------------------------------------) str
(") p n
(C       write\(ui,*\) " EM FEM, lambda : ", lambda*1.0d9, "nm") c n
(C       write\(ui,*\) "-----------------------------------------------") N
(C       write\(ui,*\)) N
(C C) N
(      freq = 1.0d0/lambda) p n
(      k_0 = 2.0d0*pi*freq) N
(C) c n
(C  Index number of the core materials \(material with highest Re\(eps_eff\)\)) N
(      ) p
(if) K
(\() p
(dble) K
(\(eps_eff\(1\)\) ) p
(.gt.) K
( ) p
(dble) K
(\(eps_eff\(2\)\)\) ) p
(then) K n
(          n_core\(1\) = 1) p n
(      ) S
(else) K n
(          n_core\(1\) = 2) p n
(      ) S
(endif) K n
(      n_core\(2\) = n_core\(1\)) p n
(C  Check that the layer is not in fact homogeneous) c n
(        homogeneous_check = 0) p n
(        ) S
(do) K
( i=1,n_typ_el-1) p n
(          ) S
(if) K
(\() p
(dble) K
(\(eps_eff\(i\)\) ) p
(.ne.) K
( ) p
(dble) K
(\(eps_eff\(i+1\)\)\) ) p
(then) K n
(            homogeneous_check = 1) p n
(          ) S
(elseif) K
(\(dimag\(eps_eff\(i\)\) ) p
(.ne.) K
( dimag\(eps_eff\(i+1\)\)\) ) p
(then) K n
(            homogeneous_check = 1) p n
(          ) S
(endif) K n
(        ) p
(enddo) K n
(        ) p
(if) K
(\(homogeneous_check ) p
(.eq.) K
( 0\) ) p
(then) K n
(          ) p
(write) K
(\(emsg,*\) ") p
(py_calc_modes_1d.f: ) str
(",) p n
(     *              ") S
(FEM routine cannot handle homogeneous layers.) str
(",) p n
(     *     ") S
(Define layer as object.ThinFilm) str
(") p n
(         errco = -17) N
(         ) S
(return) K
( ) p n
(        ) S
(endif) K n
(C Parameter for shift-and-invert method - now given as input from python) c n
(C      shift_ksqr = 1.01d0*Dble\(v_refindex_n\(n_core\(1\)\)\)**2 * k_0**2) N
(C     *    - bloch_vec\(1\)**2 - bloch_vec\(2\)**2) N
(py_calc_modes.f) (Page 10/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (5/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(      ) S
(if) K
(\(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: n_core = ) str
(", n_core) p n
(        ) S
(if) K
(\(E_H_field ) p
(.eq.) K
( 1\) ) p
(then) K n
(          ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: E-Field formulation) str
(") p n
(        ) S
(else) K n
(          ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: H-Field formulation) str
(") p n
(        ) S
(endif) K n
(      ) p
(endif) K n
(C) c n
(C) N
(      ) p
(if) K
(\(E_H_field ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(do) K
( i=1,n_typ_el) p n
(          qq\(i\) = eps_eff\(i\)*k_0**2) N
(          pp\(i\) = 1.0d0) N
(        ) S
(enddo) K n
(      ) p
(elseif) K
(\(E_H_field ) p
(.eq.) K
( 2\) ) p
(then) K n
(        ) p
(do) K
( i=1,n_typ_el) p n
(          qq\(i\) = k_0**2) N
(          pp\(i\) = 1.0d0/eps_eff\(i\)) N
(        ) S
(enddo) K n
(      ) p
(else) K n
(C     Can't happen) c n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: action indef. avec E_H_field = ) str
(",) p n
(     *                  E_H_field) N
(        ) S
(write) K
(\(ui,*\) ") p
(Aborting...) str
(") p n
(         errco = -18) N
(         ) S
(return) K
( ) p n
(      ) S
(endif) K n
(C) c n
(CCCCCCCCCCCCCCCCCCCC  Loop over Adjoint and Prime  CCCCCCCCCCCCCCCCCCCCCC) N
(C) N
(      ) p
(do) K
( n_k = 1,2) p n
(C) c n
(      ) p
(if) K
( \(n_k ) p
(.eq.) K
( 1\) ) p
(then) K n
(        sol => sol1) p n
(        beta => beta1) N
(        bloch_vec_k = bloch_vec) N
(        msg = ") S
(adjoint solution) str
(") p n
(      ) S
(else) K n
(        sol => sol2) p n
(        beta => beta2) N
(        bloch_vec_k = -bloch_vec) N
(        msg = ") S
(prime solution) str
(") p n
(      ) S
(endif) K n
(C) c n
(C     Assemble the coefficient matrix A and the right-hand side F of the) N
(C     finite element equations) N
(C       if \(debug .eq. 1\) then) N
(C         write\(ui,*\) "py_calc_modes.f: Asmbly: call to asmbly") N
(C       endif) N
(      ) p
(write) K
(\(ui,*\) ") p
(EM FEM: ) str
(") p n
(      ) S
(write) K
(\(ui,') p
(\(A,A\)) str
('\) ") p
(      - assembling linear system for ) str
(", msg) p n
() N
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime1, time1\)) p n
() N
(      ) S
(call) K
( ) p
(asmbly) l
( \(bnd_cdn_i, i_base, n_msh_el, n_msh_pts, n_ddl, neq,) p n
(     *  nodes_per_el, shift_ksqr, bloch_vec_k, n_typ_el, pp, qq, ) N
(     * table_nod, awk\(ip_table_N_E_F\), type_el, awk\(ip_eq\),) N
(     *  awk\(ip_period_N\), awk\(ip_period_N_E_F\), mesh_xy, ) N
(     *  bwk\(jp_x_N_E_F\), nonz, awk\(ip_row\), awk\(ip_col_ptr\), ) N
(py_calc_modes.f) (Page 11/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(     *  cwk\(kp_mat1_re\), cwk\(kp_mat1_im\), bwk\(jp_mat2\), awk\(ip_work\)\)) p n
() N
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime2, time2\)) p n
(      ) S
(write) K
(\(ui,') p
(\(A,F6.2,A\)) str
('\) ') p
(           cpu time  = ) str
(', \(time2-time1\), ) p n
(     *   ') S
( secs.) str
(') p n
(      ) S
(write) K
(\(ui,') p
(\(A,F6.2,A\)) str
('\) ') p
(           wall time = ) str
(', \(stime2-stime1\),) p n
(     *   ') S
( secs.) str
(') p n
(C) c n
(C     factorization of the globale matrice) N
(C     -----------------------------------) N
(C) N
(      ) p
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Adjoint\(1\) / Prime\(2\)) str
(", n_k) p n
(c        write\(ui,*\) "py_calc_modes.f: factorisation: call to znsy") c n
(      ) p
(endif) K n
(C) c n
(C       if \(debug .eq. 1\) then) N
(C         write\(ui,*\) "py_calc_modes.f: call to valpr") N
(C       endif) N
(      ) p
(write) K
(\(ui,*\) ") p
(     - solving linear system) str
(") p n
() N
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime1, time1\)) p n
() N
(      ) S
(call) K
( ) p
(valpr_64) l
( \(i_base, nvect, n_modes, neq, itermax, ltrav,) p n
(     *  tol, nonz, awk\(ip_row\), awk\(ip_col_ptr\), cwk\(kp_mat1_re\),) N
(     *  cwk\(kp_mat1_im\), bwk\(jp_mat2\), bwk\(jp_vect1\), bwk\(jp_vect2\),) N
(     *  bwk\(jp_workd\), bwk\(jp_resid\), bwk\(jp_vschur\), beta,) N
(     *  bwk\(jp_trav\), bwk\(jp_vp\), cwk\(kp_rhs_re\), cwk\(kp_rhs_im\),) N
(     *  cwk\(kp_lhs_re\), cwk\(kp_lhs_im\), n_conv, ls_data,) N
(     *  numeric, control, info_umf, debug, errco, emsg\)) N
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime2, time2\)) p n
(      ) S
(write) K
(\(ui,') p
(\(A,F6.2,A\)) str
('\) ') p
(           cpu time  = ) str
(', \(time2-time1\), ) p n
(     *   ') S
( secs.) str
(') p n
(      ) S
(write) K
(\(ui,') p
(\(A,F6.2,A\)) str
('\) ') p
(           wall time = ) str
(', \(stime2-stime1\),) p n
(     *   ') S
( secs.) str
(') p n
(c   ) c n
(      ) p
(if) K
( \(errco ) p
(.ne.) K
( 0\) ) p
(then) K n
(          ) p
(return) K n
(      ) p
(endif) K n
() p n
(      ) S
(if) K
( \(n_conv ) p
(.ne.) K
( n_modes\) ) p
(then) K n
(         ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: convergence problem in valpr_64) str
(") p n
(c         write\(ui,*\) "You should probably increase resolution of mesh!") c n
(         ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: n_conv != n_modes : ) str
(",) p n
(     *    n_conv, n_modes) N
(c        write\(ui,*\) "n_core\(1\), v_refindex_n\(n_core\(1\)\) = ",) c n
(c    *                n_core\(1\), v_refindex_n\(n_core\(1\)\)) N
(         ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Aborting...) str
(") p n
(         errco = -19) N
(         ) S
(return) K
( ) p n
(      ) S
(endif) K n
(c) c n
(      time1_fact = ls_data\(1\)) p n
(      time2_fact = ls_data\(2\)) N
(c) c n
(      time1_arpack = ls_data\(3\)) p n
(      time2_arpack = ls_data\(4\)) N
(C) c n
(      ) p
(do) K
( i=1,n_modes) p n
(        z_tmp0 = beta\(i\)) N
(        z_tmp = 1.0d0/z_tmp0+shift_ksqr) N
(        z_beta = ) S
(sqrt) K
(\(z_tmp\)) p n
(py_calc_modes.f) (Page 12/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (6/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(C       Mode classification - we want the forward propagating mode) c n
(        ) p
(if) K
( \() p
(abs) K
(\(imag\(z_beta\)/z_beta\) ) p
(.lt.) K
( 1.0d-8\) ) p
(then) K n
(C         re\(z_beta\) > 0 for forward propagating mode) c n
(          ) p
(if) K
( \() p
(dble) K
(\(z_beta\) ) p
(.lt.) K
( 0\) z_beta = -z_beta) p n
(        ) S
(else) K n
(C         im\(z_beta\) > 0 for forward decaying evanescent mode) c n
(          ) p
(if) K
( \(imag\(z_beta\) ) p
(.lt.) K
( 0\) z_beta = -z_beta) p n
(        ) S
(endif) K n
(C     !  Effective iindex) c n
(C        z_beta = sqrt\(z_tmp\)/k_0) N
(        beta\(i\) = z_beta) p n
(      ) S
(enddo) K n
(c) c n
(      ) p
(call) K
( ) p
(get_clocks) l
(\(stime1_postp, time1_postp\)) p n
(C) c n
(      ) p
(call) K
( ) p
(z_indexx) l
( \(n_modes, beta, iindex\)) p n
(C) c n
(C       The eigenvectors will be stored in the array sol) N
(C       The eigen_modesues and eigenvectors will be renumbered) N
(C                 using the permutation vector iindex) N
(        ) p
(call) K
( ) p
(array_sol) l
( \(bnd_cdn_i, n_modes, n_msh_el, n_msh_pts, ) p n
(     *  n_ddl, neq, nodes_per_el, n_core, bloch_vec_k, iindex, ) N
(     *   table_nod, awk\(ip_table_N_E_F\), type_el, awk\(ip_eq\), ) N
(     *   awk\(ip_period_N\), awk\(ip_period_N_E_F\), mesh_xy, ) N
(     *   bwk\(jp_x_N_E_F\), beta, mode_pol, bwk\(jp_vp\), sol\)) N
(C) c n
(      ) p
(if) K
(\(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ') p
(iindex = ) str
(', \(iindex\(i\), i=1,n_modes\)) p n
(      ) S
(endif) K n
(      ) p
(if) K
(\(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\)) p n
(        ) S
(write) K
(\(ui,*\) ") p
(lambda, 1/lambda = ) str
(", lambda, 1.0d0/lambda) p n
(        ) S
(write) K
(\(ui,*\) \(bloch_vec_k\(i\)/\(2.0d0*pi\),i=1,2\)) p n
(        ) S
(write) K
(\(ui,*\) ") p
(sqrt\(shift_ksqr\) = ) str
(", ) p
(sqrt) K
(\(shift_ksqr\)) p n
(        ) S
(write) K
(\(ui,*\) ") p
(n_modess = ) str
(") p n
(        ) S
(do) K
( i=1,n_modes) p n
(          ) S
(write) K
(\(ui,") p
(\(i4,2\(g22.14\),2\(g18.10\)\)) str
("\) i,) p n
(     *       beta\(i\)) N
(        ) S
(enddo) K n
(      ) p
(endif) K n
(C) c n
(C  Calculate energy in each medium \(typ_el\)) N
(      ) p
(if) K
( \(n_k ) p
(.eq.) K
( 2\) ) p
(then) K n
(        ) p
(call) K
( ) p
(mode_energy) l
( \(n_modes, n_msh_el, n_msh_pts, nodes_per_el,) p n
(     *     n_core, table_nod, type_el, n_typ_el, eps_eff,) N
(     *     mesh_xy, sol, beta, mode_pol\)) N
(      ) S
(endif) K n
(C) c n
(      ) p
(enddo) K n
(C) c n
(CCCCCCCCCCCCCCCCCCCCCCCC  End Prime, Adjoint Loop  CCCCCCCCCCCCCCCCCCCCCC) N
(C) N
(C  Orthogonal integral) N
(      pair_warning = 0) p n
(      ) S
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Field product) str
(") p n
(      ) S
(endif) K n
(      overlap_file = ") p
(Normed/Orthogonal.txt) str
(") p n
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime1_J, time1_J\)) p n
(      ) S
(call) K
( ) p
(orthogonal) l
( \(n_modes, n_msh_el, n_msh_pts, nodes_per_el,) p n
(     *  n_typ_el, pp, table_nod,) N
(     *  type_el, mesh_xy, beta1, beta2,) N
(py_calc_modes.f) (Page 13/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(     *  sol1, sol2, overlap_L,) p n
(     *  overlap_file, PrintAll, pair_warning, k_0\)) N
() N
(      ) S
(if) K
( \(pair_warning ) p
(.ne.) K
( 0 ) p
(.and.) K
( n_modes ) p
(.le.) K
( 20\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Warning found 1 BM of cmplx conj) str
(") p n
(        ) S
(write) K
(\(ui,*\) ") p
(pair, increase num_BMs to include the other.) str
(") p n
(      ) S
(endif) K n
() p n
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime2_J, time2_J\)) p n
(      ) S
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: CPU time for orthogonal :) str
(",) p n
(     *  \(time2_J-time1_J\)) N
(      ) S
(endif) K n
() p n
(c     The z-component must be multiplied by -ii*beta in order to ) c n
(C     get the physical, un-normalised z-component) N
(C     \(see Eq. \(25\) of the JOSAA 2012 paper\)) N
(      ) p
(do) K
( ival=1,n_modes) p n
(        ) S
(do) K
( iel=1,n_msh_el) p n
(          ) S
(do) K
( inod=1,nodes_per_el+7) p n
(            sol1\(3,inod,ival,iel\) ) N
(     *        = ii * beta\(ival\) * sol1\(3,inod,ival,iel\)) N
(          ) S
(enddo) K n
(        ) p
(enddo) K n
(      ) p
(enddo) K n
() p n
(      ) S
(call) K
( ) p
(array_material_EM) l
( \(n_msh_el, ) p n
(     *  n_typ_el, v_refindex_n, type_el, ls_material\)) N
() N
(C) c n
(C    Save Original solution) N
(c      if \(plot_modes .eq. 1\) then) N
(c        dir_name = "Bloch_fields") N
(c        q_average = 0) N
(cC        call write_sol \(n_modes, n_msh_el, nodes_per_el, E_H_field, lambda,) N
(cC     *       beta1, sol1, mesh_file, dir_name\)) N
(cC        call write_param \(E_H_field, lambda, n_msh_pts, n_msh_el, bnd_cdn_i,) N
(cC     *       n_modes, nvect, itermax, tol, shift_ksqr, dim_x, dim_y,) N
(cC     *       mesh_file, mesh_format, n_conv, n_typ_el, eps_eff,) N
(cC     *       bloch_vec, dir_name\)) N
(c        tchar = "Bloch_fields/PDF/All_plots_pdf.geo") N
(c        open \(unit=34,file=tchar\)) N
(c          do i=1,n_modes) N
(c            call gmsh_post_process \(i, E_H_field, n_modes, n_msh_el, ) N
(c     *        n_msh_pts, nodes_per_el, table_nod, type_el, n_typ_el,) N
(c     *        v_refindex_n, mesh_xy, beta1, sol1,) N
(c     *        awk\(ip_visite\), gmsh_file_pos, dir_name,) N
(c     *        q_average, plot_real, plot_imag, plot_abs\)) N
(c          enddo) N
(c        close \(unit=34\)) N
(c      endif) N
(cC) N
() p n
(c Normalisation) c n
(      ) p
(if) K
(\(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Field  Normalisation) str
(") p n
(      ) S
(endif) K n
(      ) p
(call) K
( ) p
(get_clocks) l
(\(stime1_J, time1_J\)) p n
(      ) S
(call) K
( ) p
(normalisation) l
( \(n_modes, n_msh_el, nodes_per_el, sol1, sol2, ) p n
(     *   overlap_L\)) N
(      ) S
(call) K
( ) p
(get_clocks) l
(\(stime2_J, time2_J\)) p n
(      ) S
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(py_calc_modes.f) (Page 14/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (7/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: CPU time for normalisation :) str
(",) p n
(     *  \(time2_J-time1_J\)) N
(      ) S
(endif) K n
(C) c n
(C  Orthonormal integral) N
(      ) p
(if) K
( \(PrintAll ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: Product of normalised field) str
(") p n
(        overlap_file = ") S
(Normed/Orthogonal_n.txt) str
(") p n
(        ) S
(call) K
( ) p
(get_clocks) l
(\(stime1_J, time1_J\)) p n
(        ) S
(call) K
( ) p
(orthogonal) l
( \(n_modes, n_msh_el, n_msh_pts, nodes_per_el,) p n
(     *    n_typ_el, pp, table_nod,) N
(     *    type_el, mesh_xy, beta1, beta2,) N
(     *    sol1, sol2, overlap_L,) N
(     *    overlap_file, PrintAll, pair_warning, k_0\)) N
(        ) S
(call) K
( ) p
(get_clocks) l
(\(stime2_J, time2_J\)) p n
(          ) S
(write) K
(\(ui,*\) ") p
(py_calc_modes.f: CPU time for orthogonal :) str
(",) p n
(     *    \(time2_J-time1_J\)) N
(      ) S
(endif) K n
(C) c n
(C#########################  ) p
(End) K
( Calculations  ###########################) p n
(C) c n
(      ) p
(call) K
( ) p
(get_clocks) l
(\(stime2, time2\)) p n
(C) c n
(      ) p
(if) K
( \(debug ) p
(.eq.) K
( 1\) ) p
(then) K n
(        ) p
(write) K
(\(ui,*\)) p n
(        ) S
(write) K
(\(ui,*\) ') p
(Total CPU time \(sec.\)  = ) str
(', \(time2-time1\)) p n
() N
(        ) S
(open) K
( \() p
(unit) k
(=26,file=log_file\)) p n
(        ) S
(write) K
(\(26,*\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(Date and time formats = ccyymmdd ; hhmmss.sss) str
(") p n
(        ) S
(write) K
(\(26,*\) ") p
(Start time   = ) str
(",  start_time) p n
(        ) S
(write) K
(\(26,*\) ") p
(End time     = ) str
(",  end_time) p n
(        ) S
(write) K
(\(26,*\) ") p
(Total CPU time \(sec.\) = ) str
(",  \(time2-time1\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(LU factorisation : CPU time and % Total time = ) str
(",) p n
(     *         \(time2_fact-time1_fact\),) N
(     *         100*\(time2_fact-time1_fact\)/\(time2-time1\),") S
(%) str
(") p n
(        ) S
(write) K
(\(26,*\) ") p
(ARPACK : CPU time and % Total time = ) str
(",) p n
(     *         \(time2_arpack-time1_arpack\),) N
(     *         100*\(time2_arpack-time1_arpack\)/\(time2-time1\),") S
(%) str
(") p n
(C       write\(26,*\) "Assembly : CPU time and % Total time = ",) c n
(C    *         \(time2_asmbl-time1_asmbl\),) N
(C    *         100*\(time2_asmbl-time1_asmbl\)/\(time2-time1\),"%") N
(        ) p
(write) K
(\(26,*\) ") p
(Post-processsing : CPU time and % Total time = ) str
(",) p n
(     *         \(time2-time1_postp\),) N
(     *         100*\(time2-time1_postp\)/\(time2-time1\),") S
(%) str
(") p n
(C       write\(26,*\) "Pre-Assembly : CPU time and % Total time = ",) c n
(C    *         \(time1_asmbl-time1\),) N
(C    *         100*\(time1_asmbl-time1\)/\(time2-time1\),"%") N
(        ) p
(write) K
(\(26,*\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(lambda  = ) str
(", lambda) p n
(        ) S
(write) K
(\(26,*\) ") p
(n_msh_pts, n_msh_el, nodes_per_el  = ) str
(", n_msh_pts, ) p n
(     *    n_msh_el, nodes_per_el) N
(        ) S
(write) K
(\(26,*\) ") p
(neq, bnd_cdn_i = ) str
(", neq, bnd_cdn_i) p n
(        ) S
(if) K
( \( E_H_field ) p
(.eq.) K
( 1\) ) p
(then) K n
(          ) p
(write) K
(\(26,*\) ") p
(E_H_field         = ) str
(", E_H_field,) p n
(     *                 ") S
( \(E-Field formulation\)) str
(") p n
(        ) S
(elseif) K
( \( E_H_field ) p
(.eq.) K
( 2\) ) p
(then) K n
(          ) p
(write) K
(\(26,*\) ") p
(E_H_field         = ) str
(", E_H_field,) p n
(     *                 ") S
( \(H-Field formulation\)) str
(") p n
(       ) S
(else) K n
(          ) p
(write) K
(\(ui,*\) ") p
(MAIN \(B\): action indef. avec E_H_field = ) str
(",) p n
(     *                 E_H_field) N
(py_calc_modes.f) (Page 15/16) (Jun 01, 2024 13:38) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(          ) p
(write) K
(\(ui,*\) ") p
(Aborting...) str
(") p n
(         errco = -20) N
(         ) S
(return) K
( ) p n
(        ) S
(endif) K n
(        ) p
(write) K
(\(26,*\) ") p
(   bloch_vec = ) str
(", bloch_vec) p n
(        ) S
(write) K
(\(26,*\) ") p
(bloch_vec/pi = ) str
(", \(bloch_vec\(i\)/pi,i=1,2\)) p n
(        z_tmp = ) S
(sqrt) K
(\(shift_ksqr\)/\(2.0d0*pi\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(shift_ksqr             = ) str
(", shift_ksqr, z_tmp) p n
(        ) S
(write) K
(\(26,*\) ") p
(integer super-vector :) str
(") p n
(        ) S
(write) K
(\(26,*\) ") p
(int_used, int_max, int_used/int_max         = ) str
(",) p n
(     *    int_used , int_max, ) S
(dble) K
(\(int_used\)/) p
(dble) K
(\(int_max\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(cmplx super-vector : ) str
(") p n
(        ) S
(write) K
(\(26,*\) ") p
(cmplx_used, cmplx_max, cmplx_used/cmplx_max = ) str
(",) p n
(     *     cmplx_used, cmplx_max, ) S
(dble) K
(\(cmplx_used\)/) p
(dble) K
(\(cmplx_max\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(Real super-vector : ) str
(") p n
(        ) S
(write) K
(\(26,*\) ") p
(real_used, real_max, real_max/real_used = ) str
(",) p n
(     *     real_used, real_max, ) S
(dble) K
(\(real_max\)/) p
(dble) K
(\(real_used\)) p n
(        ) S
(write) K
(\(26,*\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(n_modes, nvect, n_conv = ) str
(", n_modes, nvect, ) p n
(     *     n_conv) N
(        ) S
(write) K
(\(26,*\) ") p
(nonz, n_msh_pts*n_modes, ) str
(",) p n
(     *     ") S
(nonz/\(n_msh_pts*n_modes\) = ) str
(",) p n
(     *  nonz, n_msh_pts*n_modes, ) S
(dble) K
(\(nonz\)/) p
(dble) K
(\(n_msh_pts*n_modes\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(nonz, nonz_max, nonz_max/nonz = ) str
(",) p n
(     *  nonz, nonz_max, ) S
(dble) K
(\(nonz_max\)/) p
(dble) K
(\(nonz\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(nonz, int_used, int_used/nonz = ) str
(",) p n
(     *  nonz, int_used, ) S
(dble) K
(\(int_used\)/) p
(dble) K
(\(nonz\)) p n
(c) c n
(c         write\(26,*\) "len_skyl, n_msh_pts*n_modes, len_skyl/\(n_msh_pts*n_modes\)) N
( = ",) N
(c     *   len_skyl, n_msh_pts*n_modes, dble\(len_skyl\)/dble\(n_msh_pts*n_modes\)) N
(c) N
(        ) p
(write) K
(\(26,*\)) p n
(        ) S
(do) K
( i=1,n_modes) p n
(          ) S
(write) K
(\(26,") p
(\(i4,2\(g22.14\),g18.10\)) str
("\) i,) p n
(     *       beta1\(i\)) N
(        ) S
(enddo) K n
(        ) p
(write) K
(\(26,*\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(n_core = ) str
(", n_core) p n
(        ) S
(write) K
(\(26,*\) ") p
(eps_eff = ) str
(", \(eps_eff\(i\),i=1,n_typ_el\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(v_refindex_n = ) str
(", \(v_refindex_n\(i\),i=1,n_typ_el\)) p n
(        ) S
(write) K
(\(26,*\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(conjugate pair problem) str
(", pair_warning, ") p
(times) str
(") p n
(        ) S
(write) K
(\(26,*\)) p n
(        ) S
(write) K
(\(26,*\) ") p
(mesh_file = ) str
(", mesh_file) p n
(        ) S
(write) K
(\(26,*\) ") p
(gmsh_file = ) str
(", gmsh_file) p n
(        ) S
(write) K
(\(26,*\) ") p
(log_file  = ) str
(", log_file) p n
(        ) S
(close) K
(\(26\)) p n
(C) c n
(        ) p
(write) K
(\(ui,*\) ") p
(   .      .      .) str
(") p n
(        ) S
(write) K
(\(ui,*\) ") p
(   .      .      .) str
(") p n
(        ) S
(write) K
(\(ui,*\) ") p
(   .      .      .) str
(") p n
(        ) S
(write) K
(\(ui,*\) ") p
(  and   we're  done!) str
(") p n
(      ) S
(endif) K n
() p n
(      ) S
(write) K
(\(ui,*\) ") p
(-----------------------------------------------) str
(") p n
(      ) S
(write) K
(\(ui,*\)) p n
(C) c n
(      ) p
(deallocate) K
(\(awk, bwk, cwk , iindex, overlap_L\)) p n
() N
(      ) S
(end) K
( ) p
(subroutine) K
( ) p
(calc_EM_modes) L n
() p n
(py_calc_modes.f) (Page 16/16) (Jun 01, 2024 13:38) title
border
grestore
(Printed by Michael Steel) rhead
(../py_calc_modes.f) (8/8) (Monday June 03, 2024) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
