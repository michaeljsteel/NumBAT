%!PS-Adobe-3.0
%%Title: mode_calcs.py
%%For: Michael Steel
%%Creator: a2ps version 4.15.5
%%CreationDate: Fri May 24 17:16:03 2024
%%BoundingBox: 24 24 571 818
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 16
%%PageOrder: Ascend
%%DocumentMedia: a4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black Blue Green Red 
%%DocumentSuppliedResources: procset a2ps-color-prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988-2017 Free Software Foundation, Inc.
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  0 setgray
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.5 0.5 1 setrgbcolor
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    1 setgray
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def
%%BeginResource: procset a2ps-color-prolog 2.0 1

%% Definition of the color faces.
/p {
  0 0 0 FG
  false BG
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  0 0 0 FG
  false BG
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false BG
  false UL
  false BX
  0 0 0.9 FG
  fCourier bfs scalefont setfont
  Show
} bind def

/K {
  false BG
  false UL
  false BX
  0 0 0.8 FG
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false BG
  false UL
  false BX
  0.8 0 0 FG
  fCourier bfs scalefont setfont
  Show
} bind def

/C {
  false BG
  false UL
  false BX
  0.8 0 0 FG
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/l {
  0 0 0 FG
  0.8 0.8 0 true BG
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/L {
  0 0 0 FG
  1 1 0 true BG
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/str {
  false BG
  false UL
  false BX
  0 0.5 0 FG
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  1 0 0 true BG
  false UL
  true BX
  1 1 1 FG
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul 2 div neg 0 rmoveto
    f# setfont
    0.8 0.1 0.1 FG
    c-show
  grestore
} bind def
%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 595 def
/sw 842 def
/llx 24 def
/urx 818 def
/ury 571 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 8.005733 def
/cw 4.803440 def

% Dictionary for ISO-8859-1 support
/iso1dict 6 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   501.959430 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# mode_calcs.py is a subroutine of NumBAT that contains methods to) c n
(# calculate the EM and Acoustic modes of a structure.) N
() p n
(# Copyright \(C\) 2017 Bjorn Sturmberg, Kokou Dossou.) c n
() p n
(# NumBAT is free software: you can redistribute it and/or modify) c n
(# it under the terms of the GNU General Public License as published by) N
(# the Free Software Foundation, either version 3 of the License, or) N
(# \(at your option\) any later version.) N
() p n
(# This program is distributed in the hope that it will be useful,) c n
(# but WITHOUT ANY WARRANTY; without even the implied warranty of) N
(# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the) N
(# GNU General Public License for more details.) N
() p n
(# You should have received a copy of the GNU General Public License) c n
(# along with this program. If not, see <http://www.gnu.org/licenses/>.) N
() p n
() N
() N
(import) K
( sys) p n
(import) K
( copy) p n
(from) K
( math ) p
(import) K
( *) p n
(from) K
( pathlib ) p
(import) K
( Path) p n
(import) K
( numpy as np) p n
() N
(import) K
( matplotlib) p n
() N
(import) K
( numbat) p n
(from) K
( reporting ) p
(import) K
( report_and_exit) p n
(from) K
( nbtypes ) p
(import) K
( *) p n
(import) K
( integration) p n
(import) K
( plotting) p n
(from) K
( fortran ) p
(import) K
( NumBAT) p n
() N
(sys.path.append\(") S
(../backend/) str
("\)) p n
() N
() N
(VacCSpeed = 299792458) N
() N
() N
(# allow this function to be module leve rather than class-level) c n
(def) K
( load_simulation\(prefix\):) p n
(    ) S
(return) K
( Simulation.load_simulation\(prefix\)) p n
() N
(# Checks of mesh and triangles satisfy conditions for triangulation) c n
(# Quadratic algorithm. Use on the smallest grid possible) N
(def) K
( check_triangulation\(vx, vy, triangs\):) p n
(    ) S
(# are points unique) c n
(    ) p
(print) K
(\(') p
(\\n\\nChecking triangulation goodness) str
('\)) p n
(    npts = len\(vx\)) N
(    dsepmin = 1e6) N
(    dsi=0) N
(    dsj=0) N
(    ) S
(for) K
( i ) p
(in) K
( range\(npts\):) p n
(        ) S
(for) K
( j ) p
(in) K
( range\(i+1, npts\):) p n
(            dsep = sqrt\( \(vx[i]-vx[j]\)**2 +\(vy[i]-vy[j]\)**2\)) N
(            ) S
(if) K
( dsep < dsepmin:) p n
(                dsepmin = dsep) N
(                dsi=i) N
(                dsj=j) N
(            ) N
(mode_calcs.py) (Page 1/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(print) K
(\(') p
(  Closest space of triangle points was) str
(', dsepmin\)) p n
(    ) S
(if) K
( dsepmin < 1e-11:) p n
(        msg=f') S
(Point collision at {dsi}, {dsj}: \({vx[dsi]},{vy[dsi]}\) =  \({vx[dsj]},{vy[dsj]}\).) str
(') p n
(        msg+=') S
(\\nIt seems the mesh grid reordering has failed.) str
(') p n
(        report_and_exit\(msg\)) N
() N
(    ) S
(#print\('Raw points'\)) c n
(    ) p
(#for i in range\(npts\):) c n
(    ) p
(#    print\(i, vx[i], vy[i]\)) c n
() p n
() N
(    ) S
(# is list of triangles unique) c n
(    s_vtri = set\(\)) p n
(    clean = True) N
(    ) S
(for) K
( tri ) p
(in) K
( triangs:) p n
(        stri = str\(tri\)) N
(        ) S
(if) K
( stri ) p
(in) K
( s_vtri:) p n
(            ) S
(print) K
(\(") p
(        Double triangle at) str
(", stri\)) p n
(            clean = False) N
(        ) S
(else) K
(:) p n
(            s_vtri.add\(stri\)) N
(    ) S
(if) K
( clean: ) p n
(        ) S
(print) K
(\(") p
(  No doubled triangles found) str
("\)) p n
(    ) S
(else) K
(:) p n
(        ) S
(print) K
(\(") p
(  Found doubled triangles) str
("\)) p n
() N
(       ) N
() N
() N
(# helper class for plotting. factors common info from Simulation that each mode ) c n
(can draw on, but we only need to do once for each Sim) N
(class) K
( ModePlotHelper\(object\):) p n
() N
(    ) S
(def) K
( __init__\(self, sim\):  ) p
(# , field_type\):) c n
(        self.sim = sim) p n
(        self.setup_for_npoints = 0) N
() N
(        ) S
(# self.field_type = field_type  # Enum.FieldType) c n
(        self.plot_params = {}) p n
() N
(        self.init_arrays\(\)) N
(        self.set_plot_params\(prefix=''\)) N
() N
(    ) S
(def) K
( init_arrays\(self\):) p n
(        self.triang6p = None) N
(        self.triang1p = None) N
(        self.interper_f = None) N
(        self.v_x = None) N
(        self.v_y = None) N
(        self.m_X = None) N
(        self.m_Y = None) N
(        self.v_x6p = None) N
(        self.v_y6p = None) N
(        self.v_Fx6p = None) N
(        self.v_Fy6p = None) N
(        self.v_Fz6p = None) N
() N
(    ) S
(def) K
( cleanup\(self\):) p n
(        ) S
(# Now that these are part of the sim object,) c n
(        ) p
(# we need to get rid of them to allow pickling of sim files, as they con) c n
(tain C++ objects) N
(mode_calcs.py) (Page 2/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (1/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(        ) S
(del) K
( self.triang6p) p n
(        ) S
(del) K
( self.triang1p) p n
(        ) S
(del) K
( self.interper_f) p n
() N
(        ) S
(del) K
( self.v_x, self.v_y, self.m_X, self.m_Y) p n
(        ) S
(del) K
( self.v_x6p, self.v_y6p) p n
(        ) S
(del) K
( self.v_Fx6p, self.v_Fy6p, self.v_Fz6p) p n
() N
(        self.init_arrays\(\)) N
() N
() N
(#    def make_picklable\(self\): #before this object can be copied or saved it nee) c n
(ds internal C++ objects removed. They are rebuilt when needed.) N
(#        if not self.triang6p is None: del self.triang6p._cpp_triangulation) N
(#        if not self.triang1p is None: del self.triang1p._cpp_triangulation) N
() p n
(    ) S
(def) K
( set_plot_params\(self,  ) p
(# n_points=501, quiver_points=30,) c n
(                        xlim_min=0, xlim_max=0, ylim_min=0, ylim_max=0,) p n
(                        EM_AC=') S
(EM_E) str
(',) p n
(                        quiver_points=30,) N
(                        num_ticks=None, ticks=False, colorbar=True, contours=Fal) N
(se, contour_lst=None,) N
(                        suppress_imimre=True, pdf_png=') S
(png) str
(',) p n
(                        prefix=') S
(tmp) str
(', suffix='', decorator=plotting.Decorator\(\),) p n
( \):) N
(        ) S
(# modal_gains_PE=None,) c n
(        ) p
(# modal_gains_MB=None,) c n
(        ) p
(# modal_gains=None\):) c n
() p n
(        pathfields = numbat.NumBATApp\(\).fieldspath\(\)) N
() N
(        ) S
(if) K
( prefix ) p
(and) K
( ) p
(not) K
( Path\(pathfields\).exists\(\): Path\(pathfields\).mkdir\(\)) p n
() N
(        ) S
(if) K
( isinstance\(EM_AC, str\):  ) p
(# aim to get rid of this) c n
(            ) p
(if) K
( self.sim.is_AC\(\):) p n
(                EM_AC = FieldType.AC) N
(            ) S
(else) K
(:) p n
(                ) S
(try) K
(:) p n
(                    ) S
(# TODO:ugly that this changes from string to enum) c n
(                    EM_AC = FieldType.from_str\(EM_AC\)) p n
(                ) S
(except) K
( Exception as ex:) p n
(                    ) S
(raise) K
( ValueError\() p n
(                        ") S
(EM_AC must be either 'AC', 'EM_E' or 'EM_H'.) str
("\) ) p
(from) K
( ex) p n
() N
(        self.plot_params = {') S
(xlim_min) str
(': xlim_min, ') p
(xlim_max) str
(': xlim_max, ') p
(ylim_min) str
(': ) p n
(ylim_min,) N
(                            ') S
(ylim_max) str
(': ylim_max, ') p
(ticks) str
(': ticks, ') p
(num_ticks) str
(': num_ti) p n
(cks,) N
(                            ') S
(colorbar) str
(': colorbar, ') p
(contours) str
(': contours, ') p
(contour_lst) str
(': c) p n
(ontour_lst, ') S
(EM_AC) str
(': EM_AC,) p n
(                            ') S
(prefix) str
(': prefix, ') p
(suffix) str
(': suffix, ') p
(pdf_png) str
(': pdf_png,) p n
(                            ) S
(# 'modal_gain':modal_gain,) c n
(                            ') p
(decorator) str
(': decorator,) p n
(                            ') S
(suppress_imimre) str
(': suppress_imimre,) p n
(                            ) S
(# 'n_pts_x': n_pts_x, 'n_pts_y': n_pts_y,) c n
(                            ') p
(quiver_points) str
(': quiver_points) p n
(                            }) N
() N
() N
(    ) S
(def) K
( interpolate_mode_i\(self, ival, field_type\):) p n
(        ) S
(# self.v_Fx6p etc could propbably be made local to this function) c n
(mode_calcs.py) (Page 3/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(# construct the meshed field from fortran solution) c n
(        sim = self.sim) p n
(        i = 0) N
(        ) S
(for) K
( i_el ) p
(in) K
( np.arange\(sim.n_msh_el\):) p n
(            ) S
(for) K
( i_node ) p
(in) K
( np.arange\(6\):) p n
(                ) S
(if) K
( field_type == FieldType.EM_E ) p
(or) K
( field_type == FieldType.AC:) p n
(                    self.v_Fx6p[i] = sim.sol1[0, i_node, ival, i_el]) N
(                    self.v_Fy6p[i] = sim.sol1[1, i_node, ival, i_el]) N
(                    self.v_Fz6p[i] = sim.sol1[2, i_node, ival, i_el]) N
(                ) S
(if) K
( field_type == FieldType.EM_H:) p n
(                    self.v_Fx6p[i] = sim.sol1_H[0, i_node, ival, i_el]) N
(                    self.v_Fy6p[i] = sim.sol1_H[1, i_node, ival, i_el]) N
(                    self.v_Fz6p[i] = sim.sol1_H[2, i_node, ival, i_el]) N
(                i += 1) N
() N
(        self.v_F6p = np.sqrt\(np.abs\(self.v_Fx6p\)**2 +) N
(                             np.abs\(self.v_Fy6p\)**2 + np.abs\(self.v_Fz6p\)**2\)) N
() N
(        ) S
(# Construct rectangular  interpolated fields.) c n
(        ) p
(# Always need these ones.) c n
(        m_ReFx = self.interper_f\(self.v_Fx6p.real\)) p n
(        m_ReFy = self.interper_f\(self.v_Fy6p.real\)) N
(        m_ImFz = self.interper_f\(self.v_Fz6p.imag\)) N
(        m_AbsF = self.interper_f\(self.v_F6p\)) N
() N
(        ) S
(# often not needed for plotting, but are used for measuring fractions. \() c n
(Could fix taht?\)) N
(        m_ImFx = self.interper_f\(self.v_Fx6p.imag\)) p n
(        m_ImFy = self.interper_f\(self.v_Fy6p.imag\)) N
(        m_ReFz = self.interper_f\(self.v_Fz6p.real\)) N
() N
(        ) S
(return) K
( \(m_ReFx, m_ImFx, m_ReFy, m_ImFy, m_ReFz, m_ImFz, m_AbsF\)) p n
() N
(    ) S
(def) K
( setup_plot_grid\(self, n_points=501,  ) p
(# quiver_points=30,) c n
(                        ) p
(# xlim_min=None, xlim_max=None, ylim_min=None, ylim_max=) c n
(None\): # these zlim_ points are not actually used here) N
(                        \):) p n
() N
(        ) S
(if) K
( self.setup_for_npoints == n_points:) p n
(            ) S
(return) K
(  ) p
(# only need to repeat if the grid density changes) c n
(        self.setup_for_npoints = n_points) p n
() N
(        sim = self.sim) N
() N
(        ) S
(# field mapping) c n
(        x_tmp = []) p n
(        y_tmp = []) N
(        ) S
(for) K
( i ) p
(in) K
( np.arange\(sim.n_msh_pts\):) p n
(            x_tmp.append\(sim.mesh_xy[0, i]\)) N
(            y_tmp.append\(sim.mesh_xy[1, i]\)) N
(        x_min = np.min\(x_tmp\)) N
(        x_max = np.max\(x_tmp\)) N
(        y_min = np.min\(y_tmp\)) N
(        y_max = np.max\(y_tmp\)) N
(        area = abs\(\(x_max-x_min\)*\(y_max-y_min\)\)) N
(        self.n_pts_x = int\(n_points*abs\(x_max-x_min\)/np.sqrt\(area\)\)) N
(        self.n_pts_y = int\(n_points*abs\(y_max-y_min\)/np.sqrt\(area\)\)) N
() N
(        ) S
(# unrolling data for the interpolators) c n
(        self.table_nod = sim.table_nod.T) p n
(        self.mesh_xy = sim.mesh_xy.T) N
() N
(mode_calcs.py) (Page 4/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (2/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(# dense triangulation with multiple points) c n
(        self.v_x6p = np.zeros\(6*sim.n_msh_el\)) p n
(        self.v_y6p = np.zeros\(6*sim.n_msh_el\)) N
(        self.v_Fx6p = np.zeros\(6*sim.n_msh_el, dtype=np.complex128\)) N
(        self.v_Fy6p = np.zeros\(6*sim.n_msh_el, dtype=np.complex128\)) N
(        self.v_Fz6p = np.zeros\(6*sim.n_msh_el, dtype=np.complex128\)) N
(        self.v_triang6p = []) N
() N
(        ) S
(for) K
( i_el ) p
(in) K
( np.arange\(sim.n_msh_el\):) p n
(            ) S
(# triangles) c n
(            idx = np.arange\(6*i_el, 6*\(i_el+1\)\)) p n
(            triangles = [[idx[0], idx[3], idx[5]],) N
(                         [idx[1], idx[4], idx[3]],) N
(                         [idx[2], idx[5], idx[4]],) N
(                         [idx[3], idx[4], idx[5]]]) N
(            self.v_triang6p.extend\(triangles\)) N
() N
(        ) S
(# Create vectors v_x6p, v_y6p which are unwrapped points at nodes of eac) c n
(h element) N
(        ) p
(# i is the index for the coordinates FIND A BETTER NAME) c n
(        i = 0) p n
(        ) S
(for) K
( i_el ) p
(in) K
( np.arange\(sim.n_msh_el\):) p n
(            ) S
(for) K
( i_node ) p
(in) K
( np.arange\(6\):) p n
(                i_ex = self.table_nod[i_el, i_node]-1) N
(                ) S
(# values) c n
(                self.v_x6p[i] = self.mesh_xy[i_ex, 0]) p n
(                ) S
(# Fact that this is mesh_xy and not y_arr seems to be right) c n
(                self.v_y6p[i] = self.mesh_xy[i_ex, 1]) p n
(                i += 1) N
() N
(        self.triang6p = matplotlib.tri.Triangulation\(self.v_x6p, self.v_y6p, sel) N
(f.v_triang6p\)) N
() N
(        ) S
(# Interpolate onto triangular grid - honest to FEM elements) c n
(        ) p
(# dense triangulation with unique points) c n
(        self.v_triang1p = []) p n
(        table_nod = self.table_nod) N
(        ) S
(for) K
( i_el ) p
(in) K
( np.arange\(sim.n_msh_el\):) p n
(            triangles = [[table_nod[i_el, 0]-1, table_nod[i_el, 3]-1, table_nod[) N
(i_el, 5]-1],) N
(                         [table_nod[i_el, 1]-1, table_nod[i_el, 4]-1, table_nod[) N
(i_el, 3]-1],) N
(                         [table_nod[i_el, 2]-1, table_nod[i_el, 5]-1, table_nod[) N
(i_el, 4]-1],) N
(                         [table_nod[i_el, 3]-1, table_nod[i_el, 4]-1, table_nod[) N
(i_el, 5]-1]]) N
(            self.v_triang1p.extend\(triangles\)) N
() N
(        ) S
(# This is for testing only. Normally turn off) c n
(        ) p
(if) K
( False:) p n
(            check_triangulation\( self.mesh_xy[:,0], self.mesh_xy[:,1], self.v_tr) N
(iang1p\)) N
() N
(        ) S
(# triangulations:  x and y coords of all points, list of triangles defin) c n
(ed by triples of indices of the points) N
(        self.triang1p = matplotlib.tri.Triangulation\(self.mesh_xy[:, 0], self.me) p n
(sh_xy[:, 1], self.v_triang1p\)) N
() N
(        ) S
(# Now use the coords user would like to think in) c n
(        ) p
(# Odd that we are doing this at ModeHelper level?) c n
(        shiftx, shifty = self.sim.get_xyshift\(\)) p n
() N
(mode_calcs.py) (Page 5/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        self.v_x = np.linspace\(x_min, x_max, self.n_pts_x\) + shiftx) p n
(        self.v_y = np.linspace\(y_min, y_max, self.n_pts_y\) + shifty) N
(        self.m_X, self.m_Y = np.meshgrid\(self.v_x, self.v_y\)) N
() N
(        ) S
(# TODO: this would be much more useful *before* the FEM calc) c n
(        ) p
(print) K
(\(''') p n
(  Structure has raw domain\(x,y\)   = [{0:.5f}, {1:.5f}] x [ {2:.5f}, {3:.5f}] \(um\),) str n
(                mapped to \(x) S
(',y') p
(\) = [{4:.5f}, {5:.5f}] x [ {6:.5f}, {7:.5f}] \(um\)) str n
(                    ) S
('''.format\() p n
(            1e6*\(self.v_x[0]-shiftx\),) N
(            1e6*\(self.v_x[-1]-shiftx\),) N
(            1e6*\(self.v_y[0]-shifty\), 1e6*\(self.v_y[-1]-shifty\),) N
(            1e6*self.v_x[0], 1e6*self.v_x[-1], 1e6*self.v_y[0], 1e6*self.v_y[-1]) N
(\)\)) N
() N
(        ) S
(# building interpolators: triang1p for the finder, triang6p for the valu) c n
(es) N
(        ) p
(# TODO: could be more efficient only interpolating the fields which are ) c n
(ultimately to be used?) N
(        ) p
(# create rectangular arrays corresponding to the v_x, v_y grids) c n
() p n
(        ) S
(# There might be a cleaner way of doing this) c n
(        v_x_flat = self.m_X.flatten\(') p
(F) str
('\) - shiftx) p n
(        v_y_flat = self.m_Y.flatten\(') S
(F) str
('\) - shifty) p n
(        finder = matplotlib.tri.TrapezoidMapTriFinder\(self.triang1p\)) N
(        self.interper_f = ) S
(lambda) K
( x: matplotlib.tri.LinearTriInterpolator\() p n
(            self.triang6p, x, trifinder=finder\)\() N
(            v_x_flat, v_y_flat\).reshape\(self.n_pts_x, self.n_pts_y\)) N
() N
(    ) S
(# def plot_strain_mode_i\(self, ival\):) c n
(    ) p
(#     # TODO: this interpolation looks very old. Can we get strain directly ) c n
(from fortran?) N
(    ) p
(#     # Interpolate onto rectangular Cartesian grid) c n
() p n
(    ) S
(#     m_Fx = self.m_ReFx + 1j*self.m_ImFx) c n
(    ) p
(#     m_Fy = self.m_ReFy + 1j*self.m_ImFy) c n
(    ) p
(#     m_Fz = self.m_ReFz + 1j*self.m_ImFz) c n
(    ) p
(#     dx = self.v_x[1]-self.v_x[0]) c n
(    ) p
(#     dy = self.v_y[1]-self.v_y[0]) c n
() p n
(    ) S
(#     print\('finding gradients'\)) c n
(    ) p
(#     # TODO: Check that the axis choice checks out) c n
(    ) p
(#     del_x_Fx = np.gradient\(m_Fx, dx, axis=0\)) c n
(    ) p
(#     del_y_Fx = np.gradient\(m_Fx, dy, axis=1\)) c n
(    ) p
(#     del_x_Fy = np.gradient\(m_Fy, dx, axis=0\)) c n
(    ) p
(#     del_y_Fy = np.gradient\(m_Fy, dy, axis=1\)) c n
(    ) p
(#     del_x_Fz = np.gradient\(m_Fz, dx, axis=0\)) c n
(    ) p
(#     del_y_Fz = np.gradient\(m_Fz, dy, axis=1\)) c n
(    ) p
(#     del_z_Fx = 1j*self.sim.q_AC*m_Fx) c n
(    ) p
(#     del_z_Fy = 1j*self.sim.q_AC*m_Fy) c n
(    ) p
(#     del_z_Fz = 1j*self.sim.q_AC*m_Fz) c n
() p n
(    ) S
(#     return) c n
() p n
(    ) S
(#     self.v_x = np.linspace\(x_min, x_max, self.n_pts_x\)) c n
(    ) p
(#     # For now, get these avlues from v_x already figured out earlier.) c n
(    ) p
(#     x_min = self.v_x[0]) c n
(    ) p
(#     x_max = self.v_x[-1]) c n
(    ) p
(#     n_pts_x = len\(self.v_x\)) c n
(    ) p
(#     y_min = self.v_y[0]) c n
(    ) p
(#     y_max = self.v_y[-1]) c n
(    ) p
(#     n_pts_y = len\(self.v_y\)) c n
(mode_calcs.py) (Page 6/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (3/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(#     xy = list\(zip\(self.v_x6p, self.v_y6p\)\)) c n
() p n
(    ) S
(#     # This seems to be equivalent  to taking grid_x = self.m_Y, grid_y = s) c n
(elf.m_X) N
(    ) p
(#     # CONFIRM!) c n
(    ) p
(#     # grid_x, grid_y = np.mgrid[x_min:x_max:n_pts_x*1j, y_min:y_max:n_pts_) c n
(y*1j]  #OLD CODE) N
(    ) p
(#     grid_x, grid_y = self.m_Y, self.m_X  # NEW CODE) c n
() p n
(    ) S
(#     m_ReFx = interpolate.griddata\() c n
(    ) p
(#         xy, v_Fx6p.real, \(grid_x, grid_y\), method='linear'\)) c n
(    ) p
(#     m_ReFy = interpolate.griddata\() c n
(    ) p
(#         xy, v_Fy6p.real, \(grid_x, grid_y\), method='linear'\)) c n
(    ) p
(#     m_ReFz = interpolate.griddata\() c n
(    ) p
(#         xy, v_Fz6p.real, \(grid_x, grid_y\), method='linear'\)) c n
(    ) p
(#     m_ImFx = interpolate.griddata\() c n
(    ) p
(#         xy, v_Fx6p.imag, \(grid_x, grid_y\), method='linear'\)) c n
(    ) p
(#     m_ImFy = interpolate.griddata\() c n
(    ) p
(#         xy, v_Fy6p.imag, \(grid_x, grid_y\), method='linear'\)) c n
(    ) p
(#     m_ImFz = interpolate.griddata\() c n
(    ) p
(#         xy, v_Fz6p.imag, \(grid_x, grid_y\), method='linear'\)) c n
(    ) p
(#     m_AbsF = interpolate.griddata\() c n
(    ) p
(#         xy, v_F6p.real, \(grid_x, grid_y\), method='linear'\)) c n
() p n
(    ) S
(#     dx = grid_x[-1, 0] - grid_x[-2, 0]) c n
(    ) p
(#     dy = grid_y[0, -1] - grid_y[0, -2]) c n
() p n
(    ) S
(#     m_Fx = m_ReFx + 1j*m_ImFx) c n
(    ) p
(#     m_Fy = m_ReFy + 1j*m_ImFy) c n
(    ) p
(#     m_Fz = m_ReFz + 1j*m_ImFz) c n
(    ) p
(#     m_Fx = m_Fx.reshape\(n_pts_x, n_pts_y\)) c n
(    ) p
(#     m_Fy = m_Fy.reshape\(n_pts_x, n_pts_y\)) c n
(    ) p
(#     m_Fz = m_Fz.reshape\(n_pts_x, n_pts_y\)) c n
(    ) p
(#     m_AbsF = m_AbsF.reshape\(n_pts_x, n_pts_y\)) c n
() p n
(    ) S
(#     m_ReFx = np.real\(m_Fx\)) c n
(    ) p
(#     m_ReFy = np.real\(m_Fy\)) c n
(    ) p
(#     m_ReFz = np.real\(m_Fz\)) c n
(    ) p
(#     m_ImFx = np.imag\(m_Fx\)) c n
(    ) p
(#     m_ImFy = np.imag\(m_Fy\)) c n
(    ) p
(#     m_ImFz = np.imag\(m_Fz\)) c n
() p n
(    ) S
(#     del_x_Fx = np.gradient\(m_Fx, dx, axis=0\)) c n
(    ) p
(#     del_y_Fx = np.gradient\(m_Fx, dy, axis=1\)) c n
(    ) p
(#     del_x_Fy = np.gradient\(m_Fy, dx, axis=0\)) c n
(    ) p
(#     del_y_Fy = np.gradient\(m_Fy, dy, axis=1\)) c n
(    ) p
(#     del_x_Fz = np.gradient\(m_Fz, dx, axis=0\)) c n
(    ) p
(#     del_y_Fz = np.gradient\(m_Fz, dy, axis=1\)) c n
(    ) p
(#     del_z_Fx = 1j*sim_wguide.q_AC*m_Fx) c n
(    ) p
(#     del_z_Fy = 1j*sim_wguide.q_AC*m_Fy) c n
(    ) p
(#     del_z_Fz = 1j*sim_wguide.q_AC*m_Fz) c n
() p n
(    ) S
(#     # Flip y order as imshow has origin at top left) c n
(    ) p
(#     del_mat = np.array\([del_x_Ex[:, ::-1].real, del_x_Ey[:, ::-1].real, de) c n
(l_x_Ez[:, ::-1].real, del_x_Ex[:, ::-1].imag, del_x_Ey[:, ::-1].imag, del_x_Ez[:) N
(, ::-1].imag, del_y_Ex[:, ::-1].real, del_y_Ey[:, ::-1].real, del_y_Ez[:, ::-1].) N
(real,) N
(    ) p
(#                        del_y_Ex[:, ::-1].imag, del_y_Ey[:, ::-1].imag, del) c n
(_y_Ez[:, ::-1].imag, del_z_Ex[:, ::-1].real, del_z_Ey[:, ::-1].real, del_z_Ez[:,) N
( ::-1].real, del_z_Ex[:, ::-1].imag, del_z_Ey[:, ::-1].imag, del_z_Ez[:, ::-1].i) N
(mag]\)) N
(mode_calcs.py) (Page 7/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(#     v_labels = ["Re\($S_{xx}$\)", "Re\($S_{xy}$\)", "Re\($S_{xz}$\)", "Im\($S_{xx) c n
(}$\)", "Im\($S_{xy}$\)", "Im\($S_{xz}$\)", "Re\($S_{yx}$\)", "Re\($S_{yy}$\)", "Re\($S_{yz) N
(}$\)",) N
(    ) p
(#                 "Im\($S_{yx}$\)", "Im\($S_{yy}$\)", "Im\($S_{yz}$\)", "Re\($S_{zx) c n
(}$\)", "Re\($S_{zy}$\)", "Re\($S_{zz}$\)", "Im\($S_{zx}$\)", "Im\($S_{zy}$\)", "Im\($S_{zz) N
(}$\)"]) N
() p n
(    ) S
(#     # stress field plots) c n
(    ) p
(#     plt.clf\(\)) c n
(    ) p
(#     fig = plt.figure\(figsize=\(15, 30\)\)) c n
(    ) p
(#     for i_p, plot in enumerate\(del_mat\):) c n
(    ) p
(#         ax = plt.subplot\(6, 3, i_p+1\)) c n
(    ) p
(#         im = plt.imshow\(plot.T\)) c n
(    ) p
(#         # no ticks) c n
(    ) p
(#         plt.xticks\([]\)) c n
(    ) p
(#         plt.yticks\([]\)) c n
(    ) p
(#         # limits) c n
(    ) p
(#         if xlim_min > 0:) c n
(    ) p
(#             ax.set_xlim\(xlim_min*n_points, \(1-xlim_max\)*n_points\)) c n
(    ) p
(#         if ylim_min > 0:) c n
(    ) p
(#             ax.set_ylim\(\(1-ylim_min\)*n_points, ylim_max*n_points\)) c n
(    ) p
(#         # titles) c n
(    ) p
(#         plt.title\(v_labels[i_p], fontsize=decorator.get_font_size\() c n
(    ) p
(#             'subplot_title'\)\)) c n
(    ) p
(#         # colorbar) c n
(    ) p
(#         divider = make_axes_locatable\(ax\)) c n
(    ) p
(#         cax = divider.append_axes\("right", size="5%", pad=0.1\)) c n
(    ) p
(#         cbar = plt.colorbar\(im, cax=cax, format='%.2e'\)) c n
(    ) p
(#         if num_ticks:) c n
(    ) p
(#             cbarticks = np.linspace\() c n
(    ) p
(#                 np.min\(plot\), np.max\(plot\), num=num_ticks\)) c n
(    ) p
(#         elif ylim_min != 0:) c n
(    ) p
(#             if xlim_min/ylim_min > 3:) c n
(    ) p
(#                 cbarlabels = np.linspace\(np.min\(plot\), np.max\(plot\), num=3) c n
(\)) N
(    ) p
(#             if xlim_min/ylim_min > 1.5:) c n
(    ) p
(#                 cbarlabels = np.linspace\(np.min\(plot\), np.max\(plot\), num=5) c n
(\)) N
(    ) p
(#             else:) c n
(    ) p
(#                 cbarlabels = np.linspace\(np.min\(plot\), np.max\(plot\), num=7) c n
(\)) N
(    ) p
(#         else:) c n
(    ) p
(#             cbarlabels = np.linspace\(np.min\(plot\), np.max\(plot\), num=7\)) c n
(    ) p
(#         cbar.set_ticks\(cbarlabels\)) c n
(    ) p
(#         cbarlabels = ['%.2f' % t for t in cbarlabels]) c n
(    ) p
(#         cbar.set_ticklabels\(cbarlabels\)) c n
(    ) p
(#         if contours:) c n
(    ) p
(#             if contour_lst:) c n
(    ) p
(#                 cbarticks = contour_lst) c n
(    ) p
(#             if np.max\(np.abs\(plot[~np.isnan\(plot\)]\)\) > plot_threshold:) c n
(    ) p
(#                 CS2 = ax.contour\() c n
(    ) p
(#                     m_X, m_Y, plot.T, levels=cbarticks, colors=colors[::-1) c n
(], linewidths=\(1.5,\)\)) N
(    ) p
(#             cbar.add_lines\(CS2\)) c n
(    ) p
(#         cbar.ax.tick_params\(labelsize=decorator.get_font_size\('cbar_tick'\)) c n
(\)) N
(    ) p
(#     fig.set_tight_layout\(True\)) c n
(    ) p
(#     n_str = '') c n
(    ) p
(#     if np.imag\(sim_wguide.Eig_values[ival]\) < 0:) c n
(    ) p
(#         k_str = r'$\\Omega/2\\pi = %\(re_k\)f %\(im_k\)f i$ GHz' % \\) c n
(    ) p
(#             {'re_k': np.real\(sim_wguide.Eig_values[ival]*1e-9\),) c n
(    ) p
(#              'im_k': np.imag\(sim_wguide.Eig_values[ival]*1e-9\)}) c n
(mode_calcs.py) (Page 8/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (4/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(#     else:) c n
(    ) p
(#         k_str = r'$\\Omega/2\\pi = %\(re_k\)f + %\(im_k\)f i$ GHz' % \\) c n
(    ) p
(#             {'re_k': np.real\(sim_wguide.Eig_values[ival]*1e-9\),) c n
(    ) p
(#              'im_k': np.imag\(sim_wguide.Eig_values[ival]*1e-9\)}) c n
(    ) p
(#     plt.suptitle\('Mode #' + str\(ival\) + '   ' + k_str + '   ' +) c n
(    ) p
(#                  n_str, fontsize=decorator.get_font_size\('title'\)\)) c n
() p n
(    ) S
(#     if pdf_png == 'png':) c n
(    ) p
(#         plt.savefig\('%\(pre\)sfields/%\(s\)s_S_field_%\(i\)i%\(add\)s.png' %) c n
(    ) p
(#                     {'pre': prefix, 's': EM_AC, 'i': ival, 'add': suffix}\)) c n
(    ) p
(#     elif pdf_png == 'pdf':) c n
(    ) p
(#         plt.savefig\('%\(pre\)sfields/%\(s\)s_S_field_%\(i\)i%\(add\)s.pdf' %) c n
(    ) p
(#                     {'pre': prefix, 's': EM_AC, 'i': ival, 'add': suffix},) c n
( bbox_inches='tight'\)) N
(    ) p
(#     if not keep_plots_open:) c n
(    ) p
(#         plt.close\(\)) c n
() p n
() N
(class) K
( Mode\(object\):) p n
(    ''') S
(This is a base class for both EM and AC modes.) str
(''') p n
() N
(    ) S
(def) K
( __init__\(self, sim, m\):) p n
(        self.mode_num = m) N
(        self.sim = sim) N
(        self.fracs = []  ) S
(# fx, fy, ft, fz) c n
(        self.r0 = None  ) p
(# centre of mass) c n
(        self.w2 = None  ) p
(# second moment width) c n
(        self.r0_offset = \(0.0, 0.0\)) p n
(        self.extra_data = {}) N
(        self.analysed = False) N
(        self.interpolated = False) N
(        self.clear_mode_plot_data\(\)) N
() N
(    ) S
(def) K
( _get_mode_helper\(self\):) p n
(        ) S
(return) K
( self.sim.get_mode_helper\(\)) p n
() N
(    ) S
(def) K
( analyse_mode\(self, n_points=501, EM_field=FieldType.EM_E\):) p n
(        mh = self._get_mode_helper\(\)) N
(        ) S
(# TODO: make all this cleaner. this should happen once for all modes) c n
(        mh.setup_plot_grid\(n_points=n_points\)) p n
(        ) S
(if) K
( ) p
(not) K
( self.interpolated:) p n
() N
(            ) S
(# self.field_type=FieldType.EM_E  #REMOVE THIS REPEAT WITH plot_mode) c n
(            ) p
(if) K
( self.is_AC\(\):) p n
(                self.field_type = FieldType.AC) N
(            ) S
(else) K
(:) p n
(                self.field_type = EM_field) N
() N
(            self.interpolate_mode\(mh\)) N
(        self._analyse_mode\(mh.v_x, mh.v_y,) N
(                           self.m_ReFx, self.m_ReFy, self.m_ReFz, self.m_ImFx, s) N
(elf.m_ImFy, self.m_ImFz, self.m_AbsF\)) N
() N
(    ) S
(def) K
( plot_mode\(self, comps, EM_field=FieldType.EM_E, ax=None,) p n
(                  n_points=501, decorator=None\):  ) S
(# TODO get this random paramet) c n
(ers hooked better into mode_helper.plot_params) N
() p n
(        self.field_type = FieldType.EM_E) N
(        ) S
(if) K
( self.is_AC\(\):) p n
(            self.field_type = FieldType.AC) N
(        ) S
(else) K
(:) p n
(            self.field_type = EM_field) N
(mode_calcs.py) (Page 9/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(        mh = self._get_mode_helper\(\)) N
() N
(        ) S
(# TODO: make all this cleaner. this should happen once for all modes) c n
(        mh.setup_plot_grid\(n_points=n_points\)) p n
() N
(        ) S
(# mh.set_plot_params\(\) # can delete shortly) c n
() p n
(        ) S
(# print\(mh.plot_params\)) c n
(        ) p
(# print\('dec', mh.plot_params['decorator']\)) c n
() p n
(        ) S
(# FIX ME) c n
(        ) p
(if) K
( ) p
(not) K
( decorator ) p
(is) K
( None:) p n
(            mh.plot_params[') S
(decorator) str
('] = decorator) p n
(        ) S
(elif) K
( mh.plot_params[') p
(decorator) str
('] ) p
(is) K
( None:) p n
(            ) S
(# don't want to do this.) c n
(            mh.plot_params[') p
(decorator) str
('] = plotting.Decorator\(\)) p n
() N
(        ) S
(# Just for now) c n
(        ) p
(# mh.plot_params['decorator'].set_singleplot_axes_property\('axes.linewid) c n
(th',.5\)) N
(        ) p
(# mh.plot_params['quiver_points']=6) c n
(        ) p
(# mh.plot_params['colorbar']=False) c n
(        ) p
(# mh.plot_params['add_title']=False) c n
() p n
(        self.interpolate_mode\(mh\)) N
(        self._plot_me\(mh, comps, self.field_type, ax\)) N
(        self.clear_mode_plot_data\(\)) N
() N
(    ) S
(def) K
( plot_mode_H\(self, comps\):  ) p
(# plot magnetic field for EM modes) c n
(        self.plot_mode\(comps, EM_field=FieldType.EM_H\)) p n
() N
(    ) S
(def) K
( plot_strain\(self\):) p n
(        ) S
(if) K
( ) p
(not) K
( self.sim.is_AC\(\):) p n
(            ) S
(print) K
(\(") p
(Doing strain in an EM sim.!) str
("\)) p n
(        ) S
(print) K
(\(') p
(doing strain) str
('\)) p n
(        mode_helper = self._get_mode_helper\(\)) N
(        mode_helper.plot_strain_mode_i\(self.mode_num\)) N
() N
(    ) S
(def) K
( clear_mode_plot_data\(self\):) p n
(        self.m_ReFx = None) N
(        self.m_ImFx = None) N
(        self.m_ReFy = None) N
(        self.m_ImFy = None) N
(        self.m_ReFz = None) N
(        self.m_ImFz = None) N
(        self.m_AbsF = None) N
() N
(    ) S
(def) K
( interpolate_mode\(self, mode_helper\):) p n
(        self.interpolated = True) N
(        sim = self.sim) N
(        ival = self.mode_num) N
() N
(        mh = mode_helper) N
() N
(        \(self.m_ReFx, self.m_ImFx, self.m_ReFy, self.m_ImFy,) N
(         self.m_ReFz, self.m_ImFz, self.m_AbsF\) = mh.interpolate_mode_i\(ival, se) N
(lf.field_type\)) N
() N
(        ) S
(if) K
( self.field_type == FieldType.EM_H:  ) p
(# scale H fields by Z0 to get com) c n
(mon units and amplitude with E) N
(            mu0 = 1.25663706212e-6) p n
(mode_calcs.py) (Page 10/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (5/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            eps0 = 8.8541878128e-12) p n
(            Z0 = sqrt\(mu0/eps0\)) N
(            self.m_ReFx *= Z0) N
(            self.m_ReFy *= Z0) N
(            self.m_ReFz *= Z0) N
(            self.m_ImFx *= Z0) N
(            self.m_ImFy *= Z0) N
(            self.m_ImFz *= Z0) N
(            self.m_AbsF *= Z0) N
() N
(    ) S
(def) K
( _plot_me\(self, mode_helper, comps, field_type, ax=None\):) p n
(        v_plots = {') S
(Fxr) str
(': self.m_ReFx, ') p
(Fyr) str
(': self.m_ReFy, ') p
(Fzi) str
(': self.m_ImFz,) p n
(                   ') S
(Fxi) str
(': self.m_ImFx, ') p
(Fyi) str
(': self.m_ImFy, ') p
(Fzr) str
(': self.m_ReFz, ') p
(Fa) str n
(bs) S
(': self.m_AbsF}) p n
() N
(        ) S
(# TODO: weirdly, we only ax != None when there is one component to plot) c n
(        ) p
(if) K
( ) p
(not) K
( ax ) p
(is) K
( None ) p
(and) K
( len\(comps\) != 1:) p n
(            ) S
(print) K
(\() p n
(                ') S
(\\nError: when providing an axis to plot on, must specify exactly one modal component.) str
('\)) p n
(            ) S
(return) K n
() p n
(        mh = mode_helper) N
(        decorator = mh.plot_params[') S
(decorator) str
(']) p n
() N
(        decorator._set_for_multi\(\)) N
(        ) S
(# TODO this is a kludgy way of doing this. send it through separately) c n
(        mh.plot_params[') p
(EM_AC) str
('] = field_type) p n
() N
(        ) S
(# can't do multiplots on a provided axis \(would need a provided figure\)) c n
(        ) p
(if) K
( ax ) p
(is) K
( None:) p n
(            plotting.plot_all_components\(mh.v_x, mh.v_y, mh.m_X, mh.m_Y, v_plots) N
(,) N
(                                         mh.plot_params, self.sim, self.mode_num) N
(\)) N
() N
(        ) S
(if) K
( len\(comps\):) p n
(            decorator._set_for_single\(\)) N
(            ) S
(# options are ['Ex', 'Hx', 'ux', 'Ey', 'Hy', 'uy', 'Ez', 'Hz', 'uz',) c n
('Eabs', 'Habs', 'uabs', 'Et', 'Ht', 'ut']) N
(            ) p
(for) K
( comp ) p
(in) K
( comps:) p n
(                cc = component_t\(comp\)) N
(                plotting.plot_one_component\() N
(                    mh.m_X, mh.m_Y, v_plots, mh.plot_params, self.sim, self.mode) N
(_num, cc, ax\)) N
() N
(    ) S
(def) K
( add_mode_data\(self, d\):) p n
(        ''') S
(Adds a dictionary of user-defined information about a mode.) str n
() N
(           :param dict d: Dict of \(str, data\) tuples of user-defined information about a mode.) N
(      ) S
(''') p n
(        self.extra_data.update\(d\)) N
() N
(    ) S
(def) K
( get_mode_data\(self\):) p n
(        ''') S
(Return dictionary of user-defined information about the mode.) str n
() N
(           :return: Dictionary of user-defined information about the mode.) N
(           :rtype: dict\(str, obj\)) N
(           ) S
(''') p n
(        ) S
(return) K
( self.extra_data) p n
() N
(    ) S
(def) K
( field_fracs\(self\):) p n
(        ''') S
(Returns tuple \(*fx*, *fy*, *fz*, *ft*\) of "fraction" of mode contained in *x*, *y*, *z* or *t* \(sum of tr) str n
(mode_calcs.py) (Page 11/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(ansverse *x+y*\) components.) str n
() N
(           Note that *fraction* is defined through a simple overlap integral. It does not necessarily represent the fraction of ) N
(energy density in the component.) N
() N
(           :return: Tuple of mode fractions) N
(           :rtype: tuple\(float, float, float, float\)) N
(        ) S
(''') p n
(        ) S
(if) K
( ) p
(not) K
( self.analysed:) p n
(            ) S
(print) K
(\(') p
(mode has not being analysed) str
('\)) p n
(        ) S
(return) K
( self.fracs) p n
() N
(    ) S
(def) K
( __str__\(self\):) p n
(        ''') S
(String representation of the mode.) str
(''') p n
(        s = ') S
(Abstract mode class) str
(') p n
(        ) S
(return) K
( s) p n
() N
(    ) S
(def) K
( is_poln_ex\(self\):) p n
(        ''') S
(Returns true if mode is predominantly x-polarised \(ie if *fx*>0.7\).) str n
() N
(           :rtype: bool) N
(           ) S
(''') p n
(        polthresh = .7) N
(        ) S
(return) K
( self.fracs[0] > polthresh) p n
() N
(    ) S
(def) K
( is_poln_ey\(self\):) p n
(        ''') S
(Returns true if mode is predominantly y-polarised \(ie if *fy*>0.7\).) str n
() N
(           :rtype: bool) N
(           ) S
(''') p n
(        polthresh = .7) N
(        ) S
(return) K
( self.fracs[1] > polthresh) p n
() N
(    ) S
(def) K
( is_poln_indeterminate\(self\):) p n
(        ''') S
(Returns true if transverse polarisation is neither predominantly *x* or *y* oriented.) str n
() N
(           :rtype: bool) N
(           ) S
(''') p n
(        ) S
(return) K
( ) p
(not) K
( \(self.is_poln_ex\(\) ) p
(or) K
( self.is_poln_ey\(\)\)) p n
() N
(    ) S
(def) K
( is_EM\(self\):) p n
(        ''') S
(Returns true if the mode is an electromagnetic mode.) str n
() N
(           :rtype: bool) N
(           ) S
(''') p n
(        ) S
(return) K
( self.sim.is_EM\(\)) p n
() N
(    ) S
(def) K
( is_AC\(self\):) p n
(        ''') S
(Returns true if the mode is an acoustic mode.) str n
() N
(           :rtype: bool) N
(           ) S
(''') p n
(        ) S
(return) K
( self.sim.is_AC\(\)) p n
() N
(    ) S
(def) K
( center_of_mass\(self\):) p n
(        ''') S
(Returns the centre of mass of the mode relative to the specified origin.) str n
() N
(           :rtype: float) N
(        ) S
(''') p n
(        ) S
(return) K
( self.r0-self.r0_offset) p n
() N
(    ) S
(def) K
( second_moment_widths\(self\):) p n
(mode_calcs.py) (Page 12/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (6/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        r''') p
(Returns the second moment widths :math:`\(w_x, w_y, \\sqrt{w_x^2+w_y^2}\)` of the mode relative to) str n
( the specified origin.) N
() N
(           :rtype: \(float, float, float\)) N
(           ) S
(''') p n
(        ) S
(return) K
( self.w2) p n
() N
(    ) S
(def) K
( center_of_mass_x\(self\):) p n
(        ''') S
(Returns the $x$ component moment of the centre of mass  of the mode.) str n
() N
(           :rtype: float) N
(           ) S
(''') p n
(        ) S
(return) K
( self.r0[0]-self.r0_offset[0]) p n
() N
(    ) S
(def) K
( center_of_mass_y\(self\):) p n
(        ''') S
(Returns the $y$ component moment of the centre of mass  of the mode.) str n
() N
(           :rtype: float) N
(           ) S
(''') p n
(        ) S
(return) K
( self.r0[1]-self.r0_offset[1]) p n
() N
(    ) S
(def) K
( wx\(self\):) p n
(        ''') S
(Returns the $x$ component moment of the second moment width.) str n
() N
(           :rtype: float) N
(           ) S
(''') p n
(        ) S
(return) K
( self.w2[0]) p n
() N
(    ) S
(def) K
( wy\(self\):) p n
(        ''') S
(Returns the $y$ component moment of the second moment width.) str n
() N
(           :rtype: float) N
(           ) S
(''') p n
(        ) S
(return) K
( self.w2[1]) p n
() N
(    ) S
(def) K
( w0\(self\):) p n
(        r''') S
(Returns the combined second moment width :math:`\\sqrt{w_x^2+w_y^2}`.) str n
() N
(           :rtype: float) N
(           ) S
(''') p n
(        ) S
(return) K
( self.w2[2]) p n
() N
(    ) S
(def) K
( set_r0_offset\(self, x0, y0\):) p n
(        ''') S
(Sets the transverse position in the grid that is to be regarded as the origin for calculations of center-of-) str n
(mass.) N
() N
(           This can be useful in aligning the FEM coordinate grid with a physically sensible place in the waveguide.) N
() N
(           :param float x0: *x* position of nominal origin.) N
(           :param float y0: *y* position of nominal origin.) N
(      ) S
(''') p n
(        self.r0_offset = \(x0, y0\)) N
() N
(    ) S
(def) K
( _analyse_mode\(self, v_x, v_y, m_Refx, m_Refy, m_Refz, m_Imfx, m_Imfy, m_) p n
(Imfz, m_Absf\):) N
(        ''') S
(Perform a series of measurements on the mode *f* to determine polarisation fractions, second moment ) str n
(widths etc.) N
() N
(           :param array v_x: Vector of x points.) N
(           :param array v_y: Vector of y points.) N
(           :param array m_Refx: Matrix of real part of fx.) N
(           :param array m_Refy: Matrix of real part of fy.) N
(mode_calcs.py) (Page 13/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(           :param array m_Refz: Matrix of real part of fz.) str n
(           :param array m_Imfx: Matrix of imaginary part of fx.) N
(           :param array m_Imfy: Matrix of imaginary part of fy.) N
(           :param array m_Imfz: Matrix of imaginary part of fz.) N
(           ) S
(''') p n
(        self.analysed = True) N
(        s_fx = np.sum\(np.sum\(m_Refx*m_Refx+m_Imfx*m_Imfx\)\)) N
(        s_fy = np.sum\(np.sum\(m_Refy*m_Refy+m_Imfy*m_Imfy\)\)) N
(        s_fz = np.sum\(np.sum\(m_Refz*m_Refz+m_Imfz*m_Imfz\)\)) N
(        s_f = s_fx+s_fy+s_fz) N
(        f_x = s_fx/s_f) N
(        f_y = s_fy/s_f) N
(        f_t = f_x+f_y) N
(        f_z = s_fz/s_f) N
(        self.fracs = [f_x, f_y, f_t, f_z]) N
(        ) S
(# TODO: IS THIS RIGHT?) c n
(        [m_x, m_y] = np.meshgrid\(v_x, v_y, indexing=') p
(ij) str
('\)) p n
(        ) S
(# print\('vs', v_x[0], v_x[1], v_x[-1], v_y[0], v_y[1], v_y[-1]\)) c n
(        ) p
(# print\('sh', len\(v_x\), len\(v_y\), m_Refx.shape, m_x.shape\)) c n
(        ) p
(# print\('m_xa', m_x[0,:5]\)) c n
(        ) p
(# print\('m_xb', m_x[:5,0]\)) c n
(        ) p
(# print\('m_xb', m_x[-5:,0]\)) c n
(        ) p
(# print\('m_ya', m_y[0,:5]\)) c n
(        ) p
(# print\('m_yb', m_y[0,-5:]\)) c n
(        ) p
(# print\('m_yc', m_y[:5,0]\)) c n
() p n
(        m_mod = m_Refx*m_Refx+m_Imfx*m_Imfx+m_Refy * \\) N
(            m_Refy+m_Imfy*m_Imfy+m_Refz*m_Refz+m_Imfz*m_Imfz) N
(        m_xmod = m_x * m_mod  ) S
(# could do this by broadcasting without meshgrid?) c n
(        m_yud = np.flipud\(m_y\)) p n
(        ) S
(# Flipping upside down y to get sensible values for r0 position.) c n
(        m_ymod = m_yud * m_mod) p n
(        ) S
(# Should this happen much closer to the extraction from FEM?) c n
(        x0 = np.sum\(np.sum\(m_xmod\)\)/s_f) p n
(        y0 = np.sum\(np.sum\(m_ymod\)\)/s_f) N
(        m_x2mod = np.power\(\(m_x-x0\), 2\) * m_mod) N
(        m_y2mod = np.power\(\(m_yud-y0\), 2\) * m_mod) N
(        w2x = sqrt\(np.sum\(np.sum\(m_x2mod\)\)/s_f\)) N
(        w2y = sqrt\(np.sum\(np.sum\(m_y2mod\)\)/s_f\)) N
(        w2 = sqrt\(w2x*w2x+w2y*w2y\)) N
(# print \('sums', s_f, np.sum\(np.sum\(m_mod\)\), w2x, w2y, w2\)) c n
(        self.r0 = np.array\([x0, y0]\)) p n
(        self.w2 = np.array\([w2x, w2y, w2]\)) N
() N
() N
(class) K
( ModeEM\(Mode\):) p n
(    ''') S
(Class representing a single electromagnetic \(EM\) mode.) str
(''') p n
() N
(    ) S
(def) K
( __init__\(self, sim, m\):) p n
(        super\(\).__init__\(sim, m\)) N
() N
(    ) S
(def) K
( __str__\(self\):) p n
(        s = ') S
(EM mode # {0}) str
('.format\(self.mode_num\)) p n
(        ) S
(return) K
( s) p n
() N
(    ) S
(def) K
( _analyse_mode\(self, v_x, v_y, m_Refx, m_Refy, m_Refz, m_Imfx, m_Imfy, m_) p n
(Imfz, m_Absf\):) N
(        super\(\)._analyse_mode\(v_x, v_y, m_Refx, m_Refy,) N
(                              m_Refz, m_Imfx, m_Imfy, m_Imfz, m_Absf\)) N
() N
() N
(class) K
( ModeAC\(Mode\):) p n
(mode_calcs.py) (Page 14/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (7/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ''') p
(Class representing a single acoustic \(AC\) mode.) str
(''') p n
() N
(    ) S
(def) K
( __init__\(self, sim, m\):) p n
(        super\(\).__init__\(sim, m\)) N
() N
(        self.gain = {}  ) S
(# { \(EM_p_i, EM_s_j\): gain}) c n
(        self.gain_PE = {}) p n
(        self.gain_MB = {}) N
() N
(    ) S
(def) K
( __str__\(self\):) p n
(        s = ') S
(AC mode # {0}) str
('.format\(self.mode_num\)) p n
(        ) S
(return) K
( s) p n
() N
(    ) S
(def) K
( _analyse_mode\(self, v_x, v_y, m_Refx, m_Refy, m_Refz, m_Imfx, m_Imfy, m_) p n
(Imfz, m_Absf\):) N
(        super\(\)._analyse_mode\(v_x, v_y, m_Refx, m_Refy,) N
(                              m_Refz, m_Imfx, m_Imfy, m_Imfz, m_Absf\)) N
() N
() N
(class) K
( Simulation\(object\):) p n
(    ''') S
(Class for calculating the electromagnetic and/or acoustic modes of a ``Struct`` object.) str n
(    ) S
(''') p n
() N
(    ) S
(def) K
( __init__\(self, structure, num_modes=20, wl_nm=1, n_eff=None, shift_Hz=No) p n
(ne,) N
(                 q_AC=None, EM_sim=None, Stokes=False,) N
(                 calc_EM_mode_energy=False, calc_AC_mode_power=False, debug=Fals) N
(e\):) N
(        ''') S
(Sets up the problem for the mode calculation at a given optical wavelength `wl_nm` or acoustic waven) str n
(umber `q_AC`.) N
() N
(           For electromagnetic problems, the tool solves for the effective index or wavenumber at a given wavelength.) N
(           For acoustic problems, the tool solves for the acoustic frequency at a given wavenumber.) N
() N
(             :param Simulation structure: The waveguide structure to be solved.) N
(             :param int num_modes: The number of modes to be found.) N
(             :param float wl_nm: For electromagnetic problems, the vacuum wavelength in nanometers.) N
(             :param float n_eff: For electromagnetic problems, an estimated effective index to begin the eigenvalue search.) N
(             :param float shift_Hz: For acoustic problems, an estimated frequency offset to begin the eigenvalue search.) N
(             :param float q_AC: For acoustic problems, the acoustic wavevector of the mode.) N
(             :param float EM_sim: For acoustic problems, the results of a previously solved EM problem to speed calculatio) N
(ns.) N
(             :param bool calc_EM_mode_energy: For electromagnetic problems, whether to calculate the optical mode ener) N
(gy.) N
(             :param bool calc_AC_mode_power: For acoustic problems, whether to calculate the acoustic mode power.) N
(          ) S
(''') p n
() N
(        self.structure = structure) N
(        self.mode_plot_helper = None) N
(        self.sim_type = SimType.EM) N
() N
(        self.lambda_m = wl_nm*1e-9) N
(        self.n_eff = n_eff) N
(        self.shift_Hz = shift_Hz) N
() N
(        self.q_AC = q_AC) N
(        self.Omega_AC = None) N
(        self.EM_sim = EM_sim) N
() N
(        self.n_modes = num_modes) N
(        self.Stokes = Stokes) N
(        self.mode_pol = None) N
(mode_calcs.py) (Page 15/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        self.k_0 = 2 * np.pi / self.lambda_m) p n
(        ) S
(# just off normal incidence to avoid degeneracies) c n
(        self.k_perp = np.array\([1e-16, 1e-16]\)) p n
() N
(        self.omega_EM = 2*np.pi*speed_c/self.lambda_m  ) S
(# Angular freq in units o) c n
(f rad/s) N
(        self.calc_EM_mode_energy = calc_EM_mode_energy) p n
(        self.calc_AC_mode_power = calc_AC_mode_power) N
() N
(        self.EM_mode_energy = None) N
(        self.EM_mode_power = None) N
() N
(        self.AC_mode_energy = None) N
(        self.AC_mode_power = None) N
() N
(        self.debug = debug) N
(        self.sym_reps = None) N
(        self.point_group = PointGroup.Unknown) N
(        self.Q_method = QAcMethod.NotSet) N
(        self.ac_alpha_t = None   ) S
(# temporal acoustic loss [1/s]) c n
(        self.ac_linewidth = None   ) p
(# acoustic linewidth [Hz]) c n
(        self.ac_Qmech = None   ) p
(# acoustic mechanical Q [dimless]) c n
() p n
(        self.mode_set = []) N
(        self.r0_offset = [0, 0]  ) S
(# passed to modes when created) c n
() p n
(        self.n_msh_pts = 0   ) S
(# number of points in .msh mesh file) c n
(        self.n_msh_el = 0    ) p
(# number of elements in .msh mesh file) c n
(        self.table_nod = None) p n
(        self.type_el = None) N
(        self.type_nod = None) N
(        self.mesh_xy = None) N
(        self.ls_material = None) N
() N
(        ) S
(# Takes list of all material refractive indices) c n
(        ) p
(# Discards any that are zero) c n
(        ) p
(# Set up mapping table for refractive indices) c n
(        ) p
(# \(Why we need this is mystery\)) c n
(        ) p
(# el_conv_table_n maps the number of the material to the position in the) c n
( nonzero v_refindexn) N
(        ) p
(# el_conv_table_n[ith material] = index into v_refindexn  of non-zero re) c n
(fractive indices) N
(        ) p
(# Except for zero index materials,) c n
(        ) p
(#  it will always be {1:1, 2:2, 3:3, .., num_mats:num_mats}) c n
(        ) p
(# \(MJS: Not sure about the counting from 1, possibly needed for fortran?) c n
(\)) N
(        v_refindexn = []) p n
(        v_refindexn_tmp = np.array\() N
(            [m.refindex_n ) S
(for) K
( m ) p
(in) K
( self.structure.d_materials.values\(\)]\)) p n
(        self.el_conv_table_n = {}) N
(        i = 1) N
(        j = 1) N
(        ) S
(for) K
( n ) p
(in) K
( v_refindexn_tmp:) p n
(            ) S
(if) K
( n != 0:) p n
(                v_refindexn.append\(n\)) N
(                self.el_conv_table_n[i] = j) N
(                j += 1) N
(            i += 1) N
(        self.v_refindexn = np.array\(v_refindexn\)) N
(        v_refindexn = None) N
() N
(        ) S
(if) K
( self.structure.loss ) p
(is) K
( False:) p n
(mode_calcs.py) (Page 16/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (8/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            self.v_refindexn = self.v_refindexn.real) p n
() N
(    ) S
(def) K
( get_xyshift\(self\):) p n
(        ) S
(if) K
( self.is_EM\(\):) p n
(            ) S
(return) K
( self.structure.shift_em_x, self.structure.shift_em_y) p n
(        ) S
(else) K
(:) p n
(            ) S
(return) K
( self.structure.shift_ac_x, self.structure.shift_ac_y) p n
() N
(    ) S
(def) K
( clean_for_save\(self\):) p n
(        ) S
(if) K
( self.mode_plot_helper ) p
(is) K
( ) p
(not) K
( None:) p n
(            self.mode_plot_helper.cleanup\(\)) N
() N
(    ) S
(def) K
( save_simulation\(self, prefix\):) p n
(        self.clean_for_save\(\)) N
() N
(        ) S
(# Acoustic sims can contain EM sims which must also be clean for saving) c n
(        ) p
(if) K
( self.EM_sim ) p
(is) K
( ) p
(not) K
( None:) p n
(            self.EM_sim.clean_for_save\(\)) N
() N
(        np.savez\(prefix, simulation=self\)) N
() N
(    @staticmethod) N
(    ) S
(def) K
( load_simulation\(prefix\):) p n
(        npzfile = np.load\(prefix+') S
(.npz) str
(', allow_pickle=True\)) p n
(        ) S
(return) K
( npzfile[') p
(simulation) str
('].tolist\(\)) p n
() N
(    ) S
(def) K
( get_mode_helper\(self\):) p n
(        ) S
(if) K
( self.mode_plot_helper ) p
(is) K
( None:) p n
(            self.mode_plot_helper = ModePlotHelper\(self\)) N
() N
(        ) S
(return) K
( self.mode_plot_helper) p n
() N
(    ) S
(def) K
( is_EM\(self\):) p n
(        ''') S
(Returns true if the solver is setup for an electromagnetic problem.) str
(''') p n
(        ) S
(return) K
( self.sim_type == SimType.EM) p n
() N
(    ) S
(def) K
( is_AC\(self\):) p n
(        ''') S
(Returns true if the solver is setup for an acoustic problem.) str
(''') p n
(        ) S
(return) K
( self.sim_type == SimType.AC) p n
() N
(    ) S
(def) K
( analyse_modes\(self, n_points=501\):) p n
(        modes = self.get_modes\(\)) N
(        ) S
(for) K
( m ) p
(in) K
( modes:) p n
(            m.analyse_mode\(n_points=n_points\)) N
() N
(    ) S
(def) K
( get_modes\(self\):) p n
(        ''') S
(Returns an array of class `Mode` containing the solved electromagnetic or acoustic modes.) str n
() N
(           :rtype: numarray\(Mode\)) N
(           ) S
(''') p n
(        ) S
(if) K
( ) p
(not) K
( len\(self.mode_set\):) p n
(            ) S
(for) K
( m ) p
(in) K
( range\(self.n_modes\):) p n
(                ) S
(if) K
( self.is_EM\(\):) p n
(                    mode = ModeEM\(self, m\)) N
(                ) S
(else) K
(:) p n
(                    mode = ModeAC\(self, m\)) N
(                ) S
(# awkward and specific to do this here, but might have already b) c n
(een set in the Simulation object befores modes are created) N
(                mode.set_r0_offset\(self.r0_offset[0], self.r0_offset[1]\)) p n
(                self.mode_set.append\(mode\)) N
() N
(        ) S
(return) K
( self.mode_set) p n
(mode_calcs.py) (Page 17/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(# this is clumsy and only works if called after modes have been calced.) c n
(    ) p
(def) K
( set_r0_offset\(self, rx, ry\):) p n
(        self.r0_offset = [rx, ry]) N
(        ) S
(for) K
( m ) p
(in) K
( self.get_modes\(\):) p n
(            m.set_r0_offset\(rx, ry\)) N
() N
(    ) S
(def) K
( symmetry_classification\(self, m\):) p n
(        ''') S
(If the point group of the structure has been specified, returns the symmetry class of the given mode.) str n
() N
(           :param int m: Index of the mode of interest.) N
(           :rtype: PointGroup) N
(           ) S
(''') p n
(        ) S
(if) K
( self.point_group == PointGroup.Unknown:) p n
(            ) S
(return) K
( '') p n
(        ) S
(return) K
( ') p
({0}:{1}) str
('.format\(self.point_group.name, self.sym_reps[m].name\)) p n
() N
(    ) S
(def) K
( neff\(self, m\):) p n
(        ''') S
( Returns the effective index of EM mode `m`.) str n
() N
(        :param int m: Index of the mode of interest.) N
(        :rtype: float) N
(        ) S
(''') p n
(        assert \(self.is_EM\(\)\)) N
(        ) S
(return) K
( np.real\(self.Eig_values[m]*self.lambda_m/\(2*np.pi\)\)) p n
() N
(    ) S
(def) K
( ngroup_EM_available\(self\):) p n
(        ''') S
(Returns true if a measure of the electromagnetic group index is available.) str
(''') p n
(        ) S
(return) K
( ) p
(not) K
( \(self.EM_mode_energy ) p
(is) K
( None ) p
(or) K
( self.EM_mode_power ) p
(is) K
( None\)) p n
() N
(    ) S
(def) K
( vgroup_AC_available\(self\):) p n
(        ''') S
(Returns true if a measure of the acoustic group velocity is available.) str
(''') p n
(        ) S
(return) K
( ) p
(not) K
( \(self.AC_mode_energy ) p
(is) K
( None ) p
(or) K
( self.AC_mode_power ) p
(is) K
( None\)) p n
() N
(    ) S
(def) K
( ngroup_EM\(self, m\):) p n
(        ''') S
(Returns the group index of electromagnetic mode `m`, if available, otherwise returns zero with a warni) str n
(ng message.) N
() N
(           :param int m: Index of the mode of interest.) N
(           :return: Group index of the mode.) N
(           :rtype: float) N
(           ) S
(''') p n
() N
(        ) S
(if) K
( ) p
(not) K
( self.ngroup_EM_available\(\):) p n
(            ) S
(print) K
(\(''') p
(EM group index requires calculation of mode energy and mode power when calculating) str n
( EM modes.) N
(               Set calc_EM_mode_energy=True and calc_AC_mode_power=True in call to Simulation) S
('''\)) p n
(            ng = 0) N
() N
(        ) S
(if) K
( abs\(self.EM_mode_energy[m]\) > 0.0:) p n
(            vg = np.real\(self.EM_mode_power[m]/self.EM_mode_energy[m]\)) N
(            ng = VacCSpeed/vg) N
(        ) S
(else) K
(:) p n
(            ng = 0) N
() N
(        ) S
(return) K
( ng) p n
() N
(    ) S
(def) K
( ngroup_EM_all\(self\):) p n
(        ''') S
(Returns a numpy array of the group index of all electromagnetic modes, if available,) str n
(           otherwise returns a zero numarray with a warning message.) N
() N
(           :return: numpy array of  index of the mode.) N
(mode_calcs.py) (Page 18/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (9/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(           :rtype: array\(float\)) str n
(           ) S
(''') p n
(        ) S
(if) K
( ) p
(not) K
( self.ngroup_EM_available\(\):) p n
(            ) S
(print) K
(\(''') p
(EM group index requires calculation of mode energy and mode power when calculating) str n
( EM modes.) N
(               Set calc_EM_mode_energy=True in call to calc_EM_modes) S
('''\)) p n
(            ) S
(return) K
( np.zeros\(len\(self.Eig_values\), dtype=float\)) p n
(        vg = np.real\(self.EM_mode_power/self.EM_mode_energy\)) N
(        ng = VacCSpeed/vg) N
(        ) S
(return) K
( ng) p n
() N
(    ) S
(def) K
( kz_EM\(self, m\):) p n
(        ''') S
(Returns the wavevector in 1/m of electromagnetic mode `m`.) str n
() N
(           :param int m: Index of the mode of interest.) N
(           :return: Wavevector k in 1/m.) N
(           :rtype: float) N
(           ) S
(''') p n
(        assert \(self.is_EM\(\)\)) N
(        ) S
(return) K
( self.Eig_values[m]) p n
() N
(    ) S
(def) K
( nu_AC\(self, m\):) p n
(        ''') S
(Returns the frequency in Hz of acoustic mode `m`.) str n
() N
(           :param int m: Index of the mode of interest.) N
(           :return: Frequency :math:`\\\\nu` in Hz) N
(           :rtype: float) N
(           ) S
(''') p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.Eig_values[m]) p n
() N
(    ) S
(#def Omega_AC\(self, m\):) c n
(    ) p
(#    '''Returns the frequency in 1/s of acoustic mode `m`.) c n
() p n
(        ) S
(#    :param int m: Index of the mode of interest.) c n
(        ) p
(#    :return: Angular requency :math:`\\\\Omega` in Hz) c n
(        ) p
(#    :rtype: float) c n
(        ) p
(#    ''') c n
(        ) p
(# return self.Eig_values[m]*2*np.pi) c n
() p n
(    ) S
(def) K
( neff_all\(self\):) p n
(        ''') S
( Return an array of the effective index of all electromagnetic modes.) str n
() N
(           :return: numpy array of effective indices) N
(           :rtype: array\(float\)) N
(            ) S
(''') p n
(        assert \(self.is_EM\(\)\)) N
(        ) S
(return) K
( np.real\(self.Eig_values*self.lambda_m/\(2*np.pi\)\)) p n
() N
(    ) S
(def) K
( kz_EM_all\(self\):) p n
(        ''') S
( Return an array of the wavevector in 1/m of all electromagnetic modes.) str n
() N
(           :return: numpy array of wavevectors in 1/m) N
(           :rtype: array\(float\)) N
(            ) S
(''') p n
(        assert \(self.is_EM\(\)\)) N
(        ) S
(return) K
( self.Eig_values) p n
() N
(    ) S
(def) K
( nu_AC_all\(self\):) p n
(        ''') S
( Return an array of the frequency in Hz of all acoustic modes.) str n
() N
(           :return: numpy array of frequencies in Hz) N
(mode_calcs.py) (Page 19/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(           :rtype: array\(float\)) str n
(           ) S
(''') p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.Eig_values) p n
() N
(    ) S
(def) K
( Omega_AC_all\(self\):) p n
(        ''') S
( Return an array of the angular frequency in 1/s of all acoustic modes.) str n
() N
(           :return: numpy array of angular frequencies in 1/s) N
(           :rtype: array\(float\)) N
(           ) S
(''') p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.Eig_values*2*np.pi) p n
() N
(    ) S
(def) K
( vp_AC\(self, m\):) p n
(        ''') S
( Return the phase velocity in m/s of acoustic mode `m`.) str n
() N
(        :return: Phase velocity of acoustic mode `m` in m/s) N
(        :rtype: float) N
(        ) S
(''') p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( np.pi*2*np.real\(self.Eig_values[m]\)/self.q_AC) p n
() N
(    ) S
(def) K
( vp_AC_all\(self\):) p n
(        ''') S
( Return an array of the phase velocity in m/s of all acoustic modes.) str n
() N
(           :return: numpy array of elastic phase velocities in m/s) N
(           :rtype: array\(float\)) N
(           ) S
(''') p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( np.pi*2*np.real\(self.Eig_values\)/self.q_AC) p n
() N
(    ) S
(def) K
( vg_AC\(self, m\):) p n
(        """) S
( Return group velocity of AC mode m in m/s) str
(""") p n
(        ) S
(if) K
( self.AC_mode_energy ) p
(is) K
( None ) p
(or) K
( self.AC_mode_power ) p
(is) K
( None:) p n
(            ) S
(print) K
(\(''') p
(AC group velocity requires calculation of mode energy and mode power when calculati) str n
(ng AC modes.) N
(               Set calc_AC_mode_power=True in call to calc_AC_modes) S
('''\)) p n
(            ) S
(return) K
( 0) p n
(        vg = np.real\(self.AC_mode_power[m]/self.AC_mode_energy[m]\)) N
(        ) S
(return) K
( vg) p n
() N
(    ) S
(def) K
( vg_AC_all\(self\):) p n
(        """) S
( Return group velocity of all AC modes in m/s) str
(""") p n
(        assert \(self.is_AC\(\)\)) N
() N
(        ) S
(if) K
( self.AC_mode_energy ) p
(is) K
( None ) p
(or) K
( self.AC_mode_power ) p
(is) K
( None:) p n
(            ) S
(print) K
(\(''') p
(AC group velocity requires calculation of mode energy and mode power when calculati) str n
(ng AC modes.) N
(               Set calc_AC_mode_power=True in call to calc_AC_modes) S
('''\)) p n
(            ) S
(return) K
( np.zeros\(len\(self.Eig_values\), dtype=float\)) p n
(        vg = np.real\(self.AC_mode_power/self.AC_mode_energy\)) N
(        ) S
(return) K
( vg) p n
() N
(    ) S
(def) K
( alpha_t_AC\(self, m\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.ac_alpha_t[m]) p n
() N
(    ) S
(def) K
( alpha_t_AC_all\(self\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.ac_alpha_t) p n
() N
(mode_calcs.py) (Page 20/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (10/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(# spatial loss [1/m]  #TODO: surely this should be the group velocity for sc) c n
(aling between spatial and temporal decays #Which is a problem because it require) N
(s knowing vg) N
(    ) p
(def) K
( alpha_s_AC\(self, m\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(print) K
(\(') p
(alpha_s:) str
('\)) p n
(        ) S
(print) K
(\(self.alpha_t_AC\(m\)\)) p n
(        ) S
(print) K
(\(self.vg_AC\(m\)\)) p n
(        ) S
(return) K
( self.alpha_t_AC\(m\)/self.vg_AC\(m\)) p n
() N
(    ) S
(def) K
( alpha_s_AC_all\(self\):  ) p
(# spatial loss [1/m]) c n
(        assert \(self.is_AC\(\)\)) p n
(        ) S
(return) K
( self.alpha_t_AC_all/self.vg_AC_all) p n
() N
(    ) S
(def) K
( Qmech_AC\(self, m\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.ac_Qmech[m]) p n
() N
(    ) S
(def) K
( Qmech_AC_all\(self\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.ac_Qmech) p n
() N
(    ) S
(def) K
( linewidth_AC\(self, m\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.ac_linewidth[m]) p n
() N
(    ) S
(def) K
( linewidth_AC_all\(self\):) p n
(        assert \(self.is_AC\(\)\)) N
(        ) S
(return) K
( self.ac_linewidth) p n
() N
(    ) S
(def) K
( analyse_symmetries\(self, ptgrp\):) p n
(        self.point_group = ptgrp) N
(        symlist = integration.symmetries\(self\)) N
(        self.sym_reps = []) N
(        ) S
(if) K
( ptgrp == PointGroup.C2V:) p n
(            ) S
(for) K
( m, sym ) p
(in) K
( enumerate\(symlist\):) p n
(                ) S
(if) K
( sym == \(1, 1, 1\):) p n
(                    self.sym_reps.append\(SymRep.A\)) N
(                ) S
(elif) K
( sym == \(-1, 1, -1\):) p n
(                    self.sym_reps.append\(SymRep.B1\)) N
(                ) S
(elif) K
( sym == \(1, -1, -1\):) p n
(                    self.sym_reps.append\(SymRep.B2\)) N
(                ) S
(elif) K
( sym == \(-1, -1, 1\):) p n
(                    self.sym_reps.append\(SymRep.B3\)) N
(                ) S
(else) K
(:) p n
(                    ) S
(print) K
(\(') p
(Warning: Unknown symmetry pattern) str
(', sym\)) p n
(                    self.sym_reps.append\(SymRep.Unknown\)) N
() N
(        ) S
(else) K
(:) p n
(            ) S
(print) K
(\(") p
(unknown symmetry properties in mode_calcs) str
("\)) p n
() N
(    ) S
(# TODO: make sure this is not done more than once on the same Simulation) c n
(    ) p
(def) K
( calc_acoustic_losses\(self, fixed_Q=None\):) p n
(        alpha = None) N
(        ) S
(if) K
( fixed_Q ) p
(is) K
( None:) p n
(            self.Q_method = QAcMethod.Intrinsic) N
() N
(            ) S
(# Calc alpha \(loss\) Eq. 45) c n
(            ) p
(print) K
(\(") p
(Acoustic loss calc) str
("\)) p n
(            nnodes = 6  ) S
(# TODO: is this right?) c n
(            ) p
(try) K
(:) p n
(                ) S
(if) K
( self.EM_sim.structure.inc_shape ) p
(in) K
( self.EM_sim.structure.line) p n
(mode_calcs.py) (Page 21/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(ar_element_shapes:) p n
(                    alpha = NumBAT.ac_alpha_int_v2\(self.n_modes,) N
(                                                   self.n_msh_el, self.n_msh_pts) N
(, nnodes,) N
(                                                   self.table_nod, self.type_el,) N
( self.mesh_xy,) N
(                                                   self.structure.n_typ_el_AC, s) N
(elf.structure.eta_tensor,) N
(                                                   self.q_AC, self.Omega_AC, sel) N
(f.sol1,) N
(                                                   ) S
(# sim_AC.AC_mode_power\) # app) c n
(ropriate for alpha in [1/m]) N
(                                                   self.AC_mode_energy\)  ) p
(# appro) c n
(priate for alpha in [1/s]) N
(                ) p
(else) K
(:) p n
(                    ) S
(if) K
( self.EM_sim.structure.inc_shape ) p
(not) K
( ) p
(in) K
( self.EM_sim.struct) p n
(ure.curvilinear_element_shapes:) N
(                        ) S
(print) K
(\(") p
(Warning: ac_alpha_int - not sure if mesh contains curvi-linear elements) str
() p n
(",) N
(                              ") S
(\\n using slow quadrature integration by default.\\n\\n) str
("\)) p n
(                    Fortran_debug = 0) N
(                    ) S
(# not sure why this is needed by ac_alpha_int) c n
(                    overlap = np.zeros\(self.n_modes, dtype=complex\)) p n
(                    alpha = NumBAT.ac_alpha_int\(self.n_modes,) N
(                                                self.n_msh_el, self.n_msh_pts, n) N
(nodes,) N
(                                                self.table_nod, self.type_el, se) N
(lf.mesh_xy,) N
(                                                self.structure.n_typ_el_AC, self) N
(.structure.eta_tensor,) N
(                                                self.q_AC, self.Omega_AC, self.s) N
(ol1,) N
(                                                ) S
(# sim_AC.AC_mode_power, Fortran_) c n
(debug\) # appropriate for alpha in [1/m]) N
(                                                self.AC_mode_energy, Fortran_deb) p n
(ug\)  ) S
(# appropriate for alpha in [1/s]) c n
(            ) p
(except) K
( KeyboardInterrupt:) p n
(                ) S
(print) K
(\(") p
(\\n\\n Routine ac_alpha_int interrupted by keyboard.\\n\\n) str
("\)) p n
(            self.ac_alpha_t = np.real\(alpha\)) N
(            ) S
(# Q_factors = 0.5*\(q_AC/alpha\)*np.ones\(n_modes\) # appropriate for al) c n
(pha in [1/m]) N
(            ) p
(# appropriate for alpha in [1/s]) c n
(            self.ac_Qmech = 0.5*\(np.real\(self.Omega_AC\) /) p n
(                                 self.ac_alpha_t\)*np.ones\(self.n_modes\)) N
(        ) S
(else) K
(:) p n
(            self.Q_method = QAcMethod.Fixed) N
(            ) S
(# factor of a 1/2 because alpha is for power!) c n
(            ) p
(# alpha [1/m] = Omega_AC/\(2*vg*fixed_Q\) = q_AC/fixed_Q) c n
(            ) p
(# alpha [1/s] = vg * alpha [1/m]) c n
(            ) p
(# alpha [1/s] = Omega_AC/\(2*fixed_Q\)) c n
(            ) p
(# alpha = 0.5*\(q_AC/fixed_Q\)*np.ones\(n_modes\) # appropriate for alph) c n
(a in [1/m]) N
(            self.ac_Qmech = fixed_Q*np.ones\(self.n_modes\)) p n
(            ) S
(# appropriate for alpha in [1/s]) c n
(            self.ac_alpha_t = 0.5 * \\) p n
(                \(np.real\(self.Omega_AC\)/fixed_Q\)*np.ones\(self.n_modes\)) N
() N
(        ) S
(# SBS linewidth of each resonance in [Hz]   #TODO: not sure about the 1/) c n
(pi.) N
(        self.ac_linewidth = self.ac_alpha_t/np.pi) p n
(        ) S
(# If linewdith should be amplitude rate in Hz, wouldn't it be) c n
(        ) p
(# alpha/\(2 * 2pi\)  since alpha is a power decay rate) c n
(mode_calcs.py) (Page 22/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (11/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23-24) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(def) K
( calc_EM_modes\(self\):) p n
(        """) S
( Run a Fortran FEM calculation to find the optical modes.) str n
() N
(        Returns a ``Simulation`` object that has these key values:) N
() N
(        Eig_values: a 1d array of Eigenvalues \(propagation constants\) in [1/m]) N
() N
(        sol1: the associated Eigenvectors, ie. the fields, stored as [field comp, node nu on element, Eig value, el nu]) N
() N
(        EM_mode_power: the power in the optical modes. Note this power is negative for modes travelling in the negative) N
(                       z-direction, eg the Stokes wave in backward SBS.) N
(        ) S
(""") p n
(        self.sim_type = SimType.EM) N
() N
(        tstruc = self.structure) N
(        ) S
(# TODO: don't think fortran really needs this. Why does it not care abou) c n
(t y dimension?) N
(        self.d_in_m = tstruc.unitcell_x*1e-9) p n
() N
(        ) S
(if) K
( self.n_modes < 20:) p n
(            self.n_modes = 20) N
(            ) S
(print) K
(\(") p
(Warning: ARPACK needs >= 20 modes so set num_modes=20.) str
("\)) p n
() N
(        ) S
(# Parameters that control how FEM routine runs) c n
(        self.E_H_field = 1  ) p
(# Selected formulation \(1=E-Field, 2=H-Field\)) c n
(        ) p
(# Boundary conditions \(0=Dirichlet,1=Neumann,2=unitcell_x\)) c n
(        bnd_cdn_i = 2) p n
(        itermax = 30  ) S
(# Maximum number of iterations for convergence) c n
(        EM_FEM_debug = self.debug  ) p
(# Fortran routines will display & save add. i) c n
(nfo) N
() p n
(        ) S
(print) K
(\(') p
( Boundary conditions: %s) str
(' %) p n
(              {0: ') S
(Dirichlet) str
(', 1: ') p
(Neumann) str
(', 2: ') p
(Periodic) str
('}[bnd_cdn_i]\)) p n
(        ) S
(# Calculate where to center the Eigenmode solver around.) c n
(        ) p
(# \(Shift and invert FEM method\)) c n
(        shift_ksqr = self.n_eff**2 * self.k_0**2) p n
() N
(        ) S
(if) K
( EM_FEM_debug == 1:) p n
(            ) S
(if) K
( ) p
(not) K
( Path\(") p
(Normed) str
("\).exists\(\): Path\(") p
(Normed) str
("\).mkdir\(\)) p n
(            ) S
(if) K
( ) p
(not) K
( Path\(") p
(Matrices) str
("\).exists\(\): Path\(") p
(Matrices) str
("\).mkdir\(\)) p n
(            ) S
(if) K
( ) p
(not) K
( Path\(") p
(Output) str
("\).exists\(\): Path\(") p
(Output) str
("\).mkdir\(\)) p n
() N
(        ) S
(# mesh sizes is at top of mail file    #TODO: would these values be bett) c n
(er as part of tstruc?) N
(        self.n_msh_pts, self.n_msh_el = map\() p n
(            int, tstruc.get_mail_data\(\)[0].split\(\)\)) N
() N
(        ) S
(print) K
(\(') p
(\\n Structure has {0} mesh points, {1} mesh elements and {2} element types.) str
('.format\() p n
(            self.n_msh_pts, self.n_msh_el, tstruc.n_typ_el\)\)) N
() N
(        ) S
(# Size of Fortran's complex superarray \(scales with mesh\)) c n
(        ) p
(# int_max, cmplx_max, real_max = NumBAT.array_size\(self.n_msh_el, self.n) c n
(_modes\)) N
(        ) p
(# if EM_FEM_debug == 1:) c n
(        ) p
(#  print\("Mesh calculated: %d nodes."%self.n_msh_el\)) c n
() p n
(        EM_FEM_debug = 0) N
(#        try:) c n
(        fort_err = 0) p n
() N
(        resm = NumBAT.calc_em_modes\(self.lambda_m, self.d_in_m, tstruc.mesh_file) N
(mode_calcs.py) (Page 23/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(,) p n
(                                    self.n_modes, self.n_msh_pts, self.n_msh_el,) N
(                                    tstruc.n_typ_el, self.v_refindexn,) N
(                                    self.k_perp, shift_ksqr, bnd_cdn_i, itermax,) N
( self.E_H_field, EM_FEM_debug,) N
(                                    ) S
(# TODO: these are all obselete, remove.) c n
(                                    tstruc.plotting_fields, tstruc.plot_real, ts) p n
(truc.plot_imag, tstruc.plot_abs\)) N
(    ) S
(#        cmplx_max, real_max, int_max\)) c n
() p n
(        self.Eig_values, self.sol1, self.mode_pol, self.table_nod, \\) N
(            self.type_el, self.type_nod, self.mesh_xy, self.ls_material, fort_er) N
(r, fort_mesg = resm) N
() N
(        ) S
(if) K
( fort_err != 0:) p n
(            ) S
(# fort_mesg comes back as a byte string.) c n
(            fort_mesg = str\(fort_mesg, ') p
(utf-8) str
('\)) p n
(            report_and_exit\(') S
(Fortran error in solving for electromagnetic modes: \\n) str
('+) p n
(                            f') S
( NumBAT Fortran error code = {fort_err}. \\n Message: \\n {fort_msg}) str
('\)) p n
() N
(#        except KeyboardInterrupt:) c n
(#            print\("\\n\\n FEM routine calc_EM_modes",\\) N
(#            "interrupted by keyboard.\\n\\n"\)) N
() p n
(        ) S
(# if not tstruc.plot_field_conc:) c n
(        ) p
(#     self.mode_pol = None) c n
() p n
(        ) S
(# if tstruc.plotting_fields != 1:) c n
(        ) p
(#     self.sol1 = None) c n
(        ) p
(#     self.v_refindexn = None) c n
(        ) p
(#     self.E_H_field = None) c n
(        ) p
(#     self.table_nod = None) c n
(        ) p
(#     self.type_el = None) c n
(        ) p
(#     self.mesh_xy = None) c n
(        ) p
(#     self.n_msh_pts = None) c n
(        ) p
(#     self.n_msh_el = None) c n
() p n
(        ) S
(# if tstruc.plt_mesh:) c n
(        ) p
(#    print\("Suppressed inefficient matplotlib plotting of mesh..."\)) c n
(            ) p
(# plotting.plot_msh\(self.mesh_xy, prefix=tstruc.mesh_file, suffix='_) c n
(EM'\)) N
() p n
() N
(# Calc unnormalised power in each EM mode Kokou equiv. of Eq. 8.) c n
(        ) p
(try) K
(:) p n
(            ) S
(print) K
(\(") p
(  Calculating EM mode powers...) str
("\)) p n
(            nnodes = 6) N
(            ) S
(if) K
( tstruc.inc_shape ) p
(in) K
( tstruc.linear_element_shapes:) p n
(                ) S
(# Integration using analytically evaluated basis function integr) c n
(als. Fast.) N
(                self.EM_mode_power = NumBAT.em_mode_energy_int_v2_ez\() p n
(                    self.k_0, self.n_modes, self.n_msh_el, self.n_msh_pts,) N
(                    nnodes, self.table_nod,) N
(                    self.mesh_xy, self.Eig_values, self.sol1\)) N
(            ) S
(else) K
(:) p n
(                ) S
(if) K
( tstruc.inc_shape ) p
(not) K
( ) p
(in) K
( tstruc.curvilinear_element_shapes:) p n
(                    ) S
(print) K
(\(") p
(Warning: em_mode_energy_int - not sure if mesh contains curvi-linear eleme) str n
(nts) S
(",) p n
(                          ") S
(\\n using slow quadrature integration by default.\\n\\n) str
("\)) p n
(            ) S
(# Integration by quadrature. Slowest.) c n
(                self.EM_mode_power = NumBAT.em_mode_energy_int_ez\() p n
(                    self.k_0, self.n_modes, self.n_msh_el, self.n_msh_pts,) N
(mode_calcs.py) (Page 24/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (12/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (25-26) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                    nnodes, self.table_nod,) p n
(                    self.mesh_xy, self.Eig_values, self.sol1\)) N
(            ) S
(# Bring Kokou's def into line with CW formulation.) c n
(            self.EM_mode_power = 2.0*self.EM_mode_power) p n
() N
(        ) S
(except) K
( KeyboardInterrupt:) p n
(            ) S
(print) K
(\(") p
(\\n\\n FEM routine EM_mode_energy_int interrupted by keyboard.\\n\\n) str
("\)) p n
() N
() N
(# Calc energy \(not power\) in each EM mode - PRA Eq. 6.) c n
(        ) p
(if) K
( self.calc_EM_mode_energy ) p
(is) K
( True:) p n
(            ) S
(print) K
(\(") p
(Calculating EM mode energies...) str
("\)) p n
(            ) S
(try) K
(:) p n
(                nnodes = 6) N
(                ) S
(# import time) c n
(                ) p
(# start = time.time\(\)) c n
(                ) p
(if) K
( tstruc.inc_shape ) p
(in) K
( tstruc.linear_element_shapes:) p n
(                    ) S
(# # Semi-analytic integration. Fastest!) c n
(                    ) p
(# else:) c n
(                    ) p
(#     if tstruc.inc_shape not in tstruc.curvilinear_element_) c n
(shapes:) N
(                    ) p
(#         print\("Warning: em_mode_e_energy_int - not sure if) c n
( mesh contains curvi-linear elements",) N
(                    ) p
(#             "\\n using slow quadrature integration by defau) c n
(lt.\\n\\n"\)) N
(                    ) p
(# # Integration by quadrature. Slowest.) c n
(                    self.EM_mode_energy = NumBAT.em_mode_e_energy_int\() p n
(                        self.n_modes, self.n_msh_el, self.n_msh_pts, nnodes,) N
(                        self.table_nod, self.type_el, tstruc.n_typ_el, self.v_re) N
(findexn,) N
(                        self.mesh_xy, self.sol1\)) N
(                ) S
(else) K
(:) p n
(                    ) S
(print) K
(\() p n
(                        ") S
(\\n\\n FEM routine em_mode_e_energy_int is not implemented for this structure. C) str n
(an't find group index. \\n\\n) S
("\)) p n
(                    self.EM_mode_energy = np.zeros\(self.n_modes, dtype=float\)) N
() N
(            ) S
(except) K
( KeyboardInterrupt:) p n
(                ) S
(print) K
(\() p n
(                    ") S
(\\n\\n FEM routine em_mode_e_energy_int interrupted by keyboard.\\n\\n) str
("\)) p n
() N
(        ) S
(# This group velocity calc is not accurate in the presence of dispersion) c n
(!) N
(        ) p
(# self.group_velocity_EM = self.EM_mode_power/self.EM_mode_power_energy) c n
() p n
(        ) S
(# If considering a the backwards propagating Stokes field.) c n
(        ) p
(if) K
( self.Stokes == True:) p n
(            self.Eig_values = -1*self.Eig_values) N
(            self.sol1 = np.conj\(self.sol1\)) N
() N
(        ) S
(# Not necessary because EM FEM mesh always normalised in area to unity.) c n
(        ) p
(# print area) c n
(        ) p
(# x_tmp = []) c n
(        ) p
(# y_tmp = []) c n
(        ) p
(# for i in np.arange\(self.n_msh_pts\):) c n
(        ) p
(#     x_tmp.append\(self.mesh_xy[0,i]\)) c n
(        ) p
(#     y_tmp.append\(self.mesh_xy[1,i]\)) c n
(        ) p
(# x_min = np.min\(x_tmp\); x_max=np.max\(x_tmp\)) c n
(        ) p
(# y_min = np.min\(y_tmp\); y_max=np.max\(y_tmp\)) c n
(        ) p
(# area = abs\(\(x_max-x_min\)*\(y_max-y_min\)\)) c n
(        ) p
(# print area) c n
(        ) p
(# self.EM_mode_power = self.EM_mode_power*area) c n
(mode_calcs.py) (Page 25/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(# def calc_EM_mode_energy\(self\):  # these require extraction of numerical props ) c n
(from Fortran. Clean that up first.) N
(#      assert\(self.is_EM\(\)\)) N
(#      if not self.EM_mode_energy is None: return  # nothing to do) N
() p n
(#    def calc_EM_mode_power\(self\):) c n
(#      assert\(self.is_EM\(\)\)) N
(#      if not self.EM_mode_power is None: return  # nothing to do) N
() p n
(#    def calc_EM_mode_power_and_energy\(self\):) c n
(#      assert\(self.is_EM\(\)\)) N
(#      self.calc_EM_mode_power\(\)) N
(#      self.calc_EM_mode_energy\(\)) N
() p n
(    ) S
(def) K
( calc_AC_modes\(self, bcs=None\):) p n
(        """) S
( Run a Fortran FEM calculation to find the acoustic modes.) str n
() N
(        Returns a ``Simulation`` object that has these key values:) N
() N
(        Eig_values: a 1d array of Eigenvalues \(frequencies\) in [1/s]) N
() N
(        sol1: the associated Eigenvectors, ie. the fields, stored as) N
(               [field comp, node num on element, Eig value, el num]) N
() N
(        AC_mode_energy: the elastic power in the acoutic modes.) N
(        ) S
(""") p n
(        self.sim_type = SimType.AC) N
() N
(        self.d_in_m = self.structure.inc_a_x*1e-9) N
() N
(        ) S
(# Build a table of materials only containing elastic properties referenc) c n
(ing the original full list in Struct) N
(        ) p
(# Needed for restricting meshes to elastic only for example) c n
(        ) p
(# el_conv_table maps the number of the acoustically active material in o) c n
(riginal material) N
(        ) p
(# list to the position in the list of acoustically active materials) c n
(        ) p
(# eg [vacuum, silicon, glass, vacuum, chalc] ->  {2:1,3:2,5:3}) c n
(        el_conv_table = {}) p n
(        i = 1) N
(        j = 1) N
(        ) S
(for) K
( mat ) p
(in) K
( self.structure.d_materials.values\(\):) p n
(            ) S
(if) K
( mat.has_elastic_properties\(\):) p n
(                el_conv_table[i] = j) N
(                j += 1) N
(            i += 1) N
() N
(        self.typ_el_AC = {}) N
(        ) S
(for) K
( k, v ) p
(in) K
( el_conv_table.items\(\):) p n
(            ) S
(# now keeps its own rather than take from EM_sim which might not exi) c n
(st) N
(            self.typ_el_AC[self.el_conv_table_n[k]] = v) p n
() N
(        ) S
(# print\('el_conv_table_n EM', self.el_conv_table_n, self.v_refindexn\)) c n
(        ) p
(# print\('el_conv_table, AC', el_conv_table\)) c n
(        ) p
(# print\('typ_el_AC', self.typ_el_AC\)) c n
() p n
(        ) S
(if) K
( self.n_modes < 20:) p n
(            self.n_modes = 20) N
(            ) S
(print) K
(\(") p
(Warning: ARPACK needs >= 20 modes so set num_modes=20.) str
("\)) p n
() N
(mode_calcs.py) (Page 26/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (13/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (27-28) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(# Parameters that control how FEM routine runs) c n
(        ) p
(# Boundary conditions \(0=Dirichlet,1=Neumann,2=unitcell_x\)) c n
(        bnd_cdn_i = 0) p n
(        ) S
(if) K
( bcs == ') p
(Open) str
(':) p n
(            ) S
(print) K
(\(') p
(Attempting open elastic boundary conditions.) str
('\)) p n
(            icond = 1  ) S
(# TODO: DO THIS ACTUILLY WORK?) c n
() p n
(        itermax = 30  ) S
(# Maximum number of iterations for convergence) c n
(        AC_FEM_debug = 0  ) p
(# Fortran routines will display & save add. info) c n
(        ARPACK_tol = 1e-10  ) p
(# ARPACK accuracy \(0.0 for machine precision\)) c n
() p n
(        ) S
(# Calculate where to center the Eigenmode solver around.) c n
(        ) p
(# \(Shift and invert FEM method\)) c n
(        ) p
(if) K
( self.shift_Hz ) p
(is) K
( None:) p n
(            ) S
(# For AC problem shift is a frequency; [shift] = s^-1.) c n
(            v_list = []) p n
(            ) S
(for) K
( el ) p
(in) K
( range\(self.structure.n_typ_el_AC\):) p n
(                ) S
(# Using acoustic velocity of longitudinal mode pg 215 Auld vol 1) c n
(.) N
(                v_list.append\() p n
(                    np.sqrt\(self.structure.c_tensor[0, 0][el]/self.structure.rho) N
([el]\)\)) N
(                ) S
(# # Using acoustic velocity of shear mode pg 215 Auld vol 1.) c n
(                ) p
(# v_list.append\(np.sqrt\(self.structure.c_tensor[3,3][el]/self.st) c n
(ructure.rho[el]\)\)) N
(            AC_velocity = np.real\(v_list\).min\(\)) p n
(            shift = np.real\(AC_velocity*self.q_AC/\(2.*np.pi\)\)) N
(            ) S
(# print "shift", shift) c n
(            shift_nu = 0.9*shift) p n
(            ) S
(# print "shift", shift) c n
(        ) p
(else) K
(:) p n
(            shift_nu = self.shift_Hz) N
() N
(        ) S
(# Take existing msh from EM FEM and manipulate mesh to exclude vacuum ar) c n
(eas.) N
(        ) p
(if) K
( self.EM_sim:) p n
(            suplied_geo_flag = 1) N
(            n_msh_el = self.EM_sim.n_msh_el) N
(            ) S
(#n_msh_pts = self.EM_sim.n_msh_pts) c n
(            type_el = self.EM_sim.type_el) p n
(            ) S
(#type_nod = self.EM_sim.type_nod) c n
(            table_nod = self.EM_sim.table_nod) p n
(            mesh_xy = self.EM_sim.mesh_xy) N
(            n_el_kept = 0) N
(            n_msh_pts_AC = 0) N
(            type_el_AC = []) N
(            table_nod_AC_tmp = np.zeros\(np.shape\(table_nod\)\)) N
(            el_convert_tbl = {}) N
(            el_convert_tbl_inv = {}) N
(            node_convert_tbl = {}) N
(            ) S
(# if self.structure.plot_mesh: #TODO turn this back on) c n
(            ) p
(#    plotting.plot_msh\(mesh_xy, prefix=self.structure.mesh_file, suf) c n
(fix='_AC-orig'\)) N
() p n
(            ) S
(for) K
( el ) p
(in) K
( range\(n_msh_el\):) p n
(                ) S
(# print type_el[el]) c n
(                ) p
(if) K
( type_el[el] ) p
(in) K
( self.typ_el_AC:) p n
(                    ) S
(# print "in", type_el[el]) c n
(                    type_el_AC.append\(self.typ_el_AC[type_el[el]]\)) p n
(                    el_convert_tbl[n_el_kept] = el) N
(                    el_convert_tbl_inv[el] = n_el_kept) N
(                    ) S
(for) K
( i ) p
(in) K
( range\(6\):) p n
(mode_calcs.py) (Page 27/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                        ) p
(# Leaves node numbering untouched) c n
(                        table_nod_AC_tmp[i][n_el_kept] = table_nod[i][el]) p n
(                    n_el_kept += 1) N
(            n_msh_el_AC = n_el_kept) N
(            ) S
(# Find unique nodes) c n
(            node_lst_tmp = []) p n
(            ) S
(for) K
( el ) p
(in) K
( range\(n_msh_el_AC\):) p n
(                ) S
(for) K
( i ) p
(in) K
( range\(6\):) p n
(                    node_lst_tmp.append\(table_nod_AC_tmp[i][el]\)) N
(            unique_nodes = list\(set\(node_lst_tmp\)\)) N
(            n_msh_pts_AC = len\(unique_nodes\)) N
(            unique_nodes = [int\(j\) ) S
(for) K
( j ) p
(in) K
( unique_nodes]) p n
(            ) S
(# Mapping unique nodes to start from zero) c n
(            ) p
(for) K
( i ) p
(in) K
( range\(n_msh_pts_AC\):) p n
(                node_convert_tbl[unique_nodes[i]] = i) N
(            ) S
(# Creating finalised table_nod.) c n
(            table_nod_AC = []) p n
(            ) S
(for) K
( i ) p
(in) K
( range\(6\):) p n
(                el_tbl = []) N
(                ) S
(for) K
( el ) p
(in) K
( range\(n_msh_el_AC\):) p n
(                    ) S
(# Note table_nod needs to be adjust back to fortran indexing) c n
(                    el_tbl.append\(node_convert_tbl[table_nod_AC_tmp[i][el]]+1\)) p n
(                table_nod_AC.append\(el_tbl\)) N
(            ) S
(# Find the coordinates of chosen nodes.) c n
(            mesh_xy_AC = np.zeros\(\(2, n_msh_pts_AC\)\)) p n
(            ) S
(for) K
( node ) p
(in) K
( unique_nodes:) p n
(                ) S
(# Note mesh_xy needs to be adjust back to fortran indexing) c n
(                mesh_xy_AC[0, node_convert_tbl[node]] = \(mesh_xy[0, node-1]\)) p n
(                mesh_xy_AC[1, node_convert_tbl[node]] = \(mesh_xy[1, node-1]\)) N
() N
(            self.el_convert_tbl = el_convert_tbl) N
(            self.el_convert_tbl_inv = el_convert_tbl_inv) N
(            self.node_convert_tbl = node_convert_tbl) N
() N
(            ) S
(# AC FEM uses Neumann B.C.s so type_nod is totally irrelevant!) c n
(            ) p
(# # Find nodes on boundaries of materials) c n
(            ) p
(# node_array = -1*np.ones\(n_msh_pts\)) c n
(            ) p
(# interface_nodes = []) c n
(            ) p
(# for el in range\(n_msh_el\):) c n
(            ) p
(#     for i in range\(6\):) c n
(            ) p
(#         node = table_nod[i][el]) c n
(            ) p
(#         # Check if first time seen this node) c n
(            ) p
(#         if node_array[node - 1] == -1: # adjust to python indexing) c n
(            ) p
(#             node_array[node - 1] = type_el[el]) c n
(            ) p
(#         else:) c n
(            ) p
(#             if node_array[node - 1] != type_el[el]:) c n
(            ) p
(#                 interface_nodes.append\(node\)) c n
(            ) p
(# interface_nodes = list\(set\(interface_nodes\)\)) c n
(            type_nod_AC = np.zeros\(n_msh_pts_AC\)) p n
() N
(            ) S
(# import matplotlib) c n
(            ) p
(# matplotlib.use\('pdf'\)) c n
(            ) p
(# import matplotlib.pyplot as plt) c n
(            ) p
(# plt.clf\(\)) c n
(            ) p
(# plt.figure\(figsize=\(13,13\)\)) c n
(            ) p
(# ax = plt.subplot\(1,1,1\)) c n
(            ) p
(# for node in unique_nodes:) c n
(            ) p
(#     if node in interface_nodes:) c n
(            ) p
(#         type_nod_AC[node_convert_tbl[node]] = bnd_cdn_i) c n
(            ) p
(#         plt.plot\(mesh_xy_AC[0,node_convert_tbl[node]], mesh_xy_AC[) c n
(1,node_convert_tbl[node]], 'ok'\)) N
(            ) p
(# ax.set_aspect\('equal'\)) c n
(mode_calcs.py) (Page 28/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (14/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (29-30) 15
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            ) p
(# plt.savefig\('boundary.pdf', bbox_inches='tight'\)) c n
(            self.n_msh_pts = n_msh_pts_AC) p n
(            self.n_msh_el = n_msh_el_AC) N
(        ) S
(# Default, indicates to use geometry subroutine in FEM routine.) c n
(        ) p
(else) K
(:  ) p
(# No EM mesh data supplied) c n
(            suplied_geo_flag = 0) p n
(            with open\(self.structure.mesh_file\) as f:) N
(                self.n_msh_pts, self.n_msh_el = [) N
(                    int\(i\) ) S
(for) K
( i ) p
(in) K
( f.readline\(\).split\(\)]) p n
(            table_nod_AC = np.zeros\(\(6, self.n_msh_el\)\)) N
(            type_el_AC = np.zeros\(self.n_msh_el\)) N
(            mesh_xy_AC = np.zeros\(\(2, self.n_msh_pts\)\)) N
(            type_nod_AC = np.zeros\(self.n_msh_pts\)) N
() N
(        ) S
(if) K
( AC_FEM_debug == 1:) p n
(            ) S
(print) K
(\(') p
(shift_nu) str
(', shift_nu\)) p n
(            ) S
(if) K
( ) p
(not) K
( Path\(") p
(Normed) str
("\).exists\(\): Path\(") p
(Normed) str
("\).mkdir\(\)) p n
(            ) S
(if) K
( ) p
(not) K
( Path\(") p
(Output) str
("\).exists\(\): Path\(") p
(Output) str
("\).mkdir\(\)) p n
(            ) S
(if) K
( ) p
(not) K
( Path\(") p
(Matrices) str
("\).exists\(\): Path\(") p
(Matrices) str
("\).mkdir\(\)) p n
() N
(        ) S
(# Size of Fortran's complex superarray \(scales with mesh\)) c n
(        ) p
(# int_max, cmplx_max, real_max = NumBAT.array_size\(self.n_msh_el, self.n) c n
(_modes\)) N
() p n
(        ) S
(print) K
(\(f') p
(\\n Structure has {self.n_msh_pts} mesh points and {self.n_msh_el} mesh elements.) str
('\)) p n
() N
(        ) S
(try) K
(:) p n
(            fort_err = 0) N
() N
(            tstruc = self.structure) N
(            show_mem_est = False) N
() N
(            resm = NumBAT.calc_ac_modes\() N
(                self.q_AC, self.n_modes,) N
(                AC_FEM_debug, show_mem_est, tstruc.mesh_file, self.n_msh_pts,) N
(                self.n_msh_el, tstruc.n_typ_el_AC, tstruc.c_tensor, tstruc.rho,) N
(                self.d_in_m, shift_nu, bnd_cdn_i, itermax, ARPACK_tol,) N
(                tstruc.plotting_fields,) N
(                suplied_geo_flag, type_nod_AC,) N
(                tstruc.symmetry_flag, table_nod_AC, type_el_AC, mesh_xy_AC\)) N
() N
(            table_nod_out, type_el_out, mesh_xy_out, \\) N
(                self.Eig_values, self.sol1, self.mode_pol, fort_err, fort_mesg =) N
( resm) N
() N
(            ) S
(if) K
( fort_err != 0:) p n
(                ) S
(# fort_mesg comes back as a byte string.) c n
(                fort_mesg = str\(fort_mesg, ') p
(utf-8) str
('\)) p n
(                report_and_exit\(') S
(Fortran error in solving for acoustic modes: \\n) str
(') p n
(                                ') S
( NumBAT Fortran error code = %d. \\n Message: \\n %s) str
(' % \(fort_) p n
(err, fort_mesg\)\)) N
() N
(            ) S
(# FEM Eigenvalue is frequency, rather than angular frequency Omega) c n
(            self.Omega_AC = self.Eig_values*2*np.pi) p n
() N
(        ) S
(except) K
( KeyboardInterrupt:) p n
(            ) S
(print) K
(\(") p
(\\n\\n FEM routine calc_AC_modes) str
(",) p n
(                  ") S
(interrupted by keyboard.\\n\\n) str
("\)) p n
() N
(        ) S
(# Retrieve the material properties of each mesh point.) c n
(        self.ls_material = NumBAT.array_material_ac\() p n
(            self.n_msh_el, self.structure.n_typ_el_AC, type_el_AC,) N
(mode_calcs.py) (Page 29/31) (May 24, 2024 14:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            self.structure.rho, self.structure.c_tensor,) p n
(            self.structure.p_tensor, self.structure.eta_tensor\)) N
() N
(        ) S
(# if self.structure.plt_mesh:  #TODO re-enable) c n
(        ) p
(#    plotting.plot_msh\(mesh_xy_AC, prefix=self.structure.mesh_file, suff) c n
(ix='_AC-in'\)) N
(        ) p
(#    plotting.plot_msh\(mesh_xy_out, prefix=self.structure.mesh_file, suf) c n
(fix='_AC-out'\)) N
() p n
(        ) S
(# if self.EM_sim is None:) c n
(        ) p
(#     table_nod_out = None) c n
(        ) p
(#     type_el_out = None) c n
(        ) p
(#     mesh_xy_out = None) c n
(        ) p
(#     self.table_nod = table_nod_AC) c n
(        ) p
(#     self.type_el = type_el_AC) c n
(        ) p
(#     self.mesh_xy = mesh_xy_AC) c n
(        ) p
(# else:) c n
(        self.table_nod = table_nod_out) p n
(        self.type_el = type_el_out) N
(        self.mesh_xy = mesh_xy_out) N
() N
(# Calc unnormalised power in each AC mode - PRA Eq. 18.) c n
(        ) p
(if) K
( self.calc_AC_mode_power ) p
(is) K
( True:) p n
(            ) S
(try) K
(:) p n
(                nnodes = 6) N
(                ) S
(if) K
( self.structure.inc_shape ) p
(in) K
( self.structure.linear_element_sha) p n
(pes:) N
(                    ) S
(# Semi-analytic integration following KD 9/9/16 notes. Faste) c n
(st!) N
(                    self.AC_mode_power = NumBAT.ac_mode_power_int_v4\() p n
(                        self.n_modes, self.n_msh_el, self.n_msh_pts,) N
(                        nnodes, self.table_nod, self.type_el, self.mesh_xy,) N
(                        self.structure.n_typ_el_AC, self.structure.c_tensor,) N
(                        self.q_AC, self.Omega_AC, self.sol1\)) N
(                ) S
(else) K
(:) p n
(                    ) S
(if) K
( self.structure.inc_shape ) p
(not) K
( ) p
(in) K
( self.structure.curvilinea) p n
(r_element_shapes:) N
(                        ) S
(print) K
(\(") p
(Warning: ac_mode_power_int - not sure if mesh contains curvi-linear el) str n
(ements) S
(",) p n
(                              ") S
(\\n using slow quadrature integration by default.\\n\\n) str
("\)) p n
(                ) S
(# Integration by quadrature. Slowest.) c n
(                    self.AC_mode_power = NumBAT.ac_mode_power_int\() p n
(                        self.n_modes, self.n_msh_el, self.n_msh_pts,) N
(                        nnodes, self.table_nod, self.type_el, self.mesh_xy,) N
(                        self.structure.n_typ_el_AC, self.structure.c_tensor_z,) N
(                        self.q_AC, self.Omega_AC, self.sol1, AC_FEM_debug\)) N
(            ) S
(except) K
( KeyboardInterrupt:) p n
(                ) S
(print) K
(\(") p
(\\n\\n FEM routine AC_mode_energy_int interrupted by keyboard.\\n\\n) str
("\)) p n
() N
() N
(# Calc unnormalised elastic energy in each AC mode - PRA Eq. 16.) c n
(        ) p
(try) K
(:) p n
(            nnodes = 6) N
(            ) S
(if) K
( self.structure.inc_shape ) p
(in) K
( self.structure.linear_element_shapes:) p n
(                ) S
(# Semi-analytic integration. Fastest!) c n
(                self.AC_mode_energy = NumBAT.ac_mode_elastic_energy_int_v4\() p n
(                    self.n_modes, self.n_msh_el, self.n_msh_pts,) N
(                    nnodes, self.table_nod, self.type_el, self.mesh_xy,) N
(                    self.structure.n_typ_el_AC, self.structure.rho,) N
(                    self.Omega_AC, self.sol1\)) N
(            ) S
(else) K
(:) p n
(                ) S
(if) K
( self.structure.inc_shape ) p
(not) K
( ) p
(in) K
( self.structure.curvilinear_el) p n
(mode_calcs.py) (Page 30/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (15/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (31) 16
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(ement_shapes:) p n
(                    ) S
(print) K
(\(") p
(Warning: ac_mode_elastic_energy_int - not sure if mesh contains curvi-linear) str n
( elements) S
(",) p n
(                          ") S
(\\n using slow quadrature integration by default.\\n\\n) str
("\)) p n
(            ) S
(# Integration by quadrature. Slowest.) c n
(                self.AC_mode_energy = NumBAT.ac_mode_elastic_energy_int\() p n
(                    self.n_modes, self.n_msh_el, self.n_msh_pts,) N
(                    nnodes, self.table_nod, self.type_el, self.mesh_xy,) N
(                    self.structure.n_typ_el_AC, self.structure.rho,) N
(                    self.Omega_AC, self.sol1, AC_FEM_debug\)) N
(        ) S
(except) K
( KeyboardInterrupt:) p n
(            ) S
(print) K
(\() p n
(                ") S
(\\n\\n FEM routine AC_mode_elastic_energy_int interrupted by keyboard.\\n\\n) str
("\)) p n
() N
() N
(def) K
( bkwd_Stokes_modes\(EM_sim\):) p n
(    """) S
( Defines the backward travelling Stokes waves as the conjugate) str n
(        of the forward travelling pump waves.) N
() N
(    Returns a ``Simulation`` object that has these key values:) N
() N
(    Eig_values: a 1d array of Eigenvalues \(propagation constants\) in [1/m]) N
() N
(    sol1: the associated Eigenvectors, ie. the fields, stored as) N
(           [field comp, node nu on element, Eig value, el nu]) N
() N
(    EM_mode_power: the power in the Stokes modes. Note this power is negative because the modes) N
(                   are travelling in the negative z-direction.) N
(    ) S
(""") p n
() N
(    EM_sim.clean_for_save\(\)) N
() N
(    Stokes_modes = copy.deepcopy\(EM_sim\)) N
(    Stokes_modes.sol1 = np.conj\(Stokes_modes.sol1\)) N
(    Stokes_modes.Eig_values = -1.0*Stokes_modes.Eig_values) N
(    Stokes_modes.EM_mode_power = -1.0*Stokes_modes.EM_mode_power) N
(    ) S
(return) K
( Stokes_modes) p n
() N
() N
(def) K
( fwd_Stokes_modes\(EM_sim\):) p n
(    """) S
( Defines the forward travelling Stokes waves as a copy) str n
(        of the forward travelling pump waves.) N
() N
(    Returns a ``Simulation`` object that has these key values:) N
() N
(    ) S
(""") p n
() N
(    EM_sim.clean_for_save\(\)) N
() N
(    Stokes_modes = copy.deepcopy\(EM_sim\)) N
(    ) S
(return) K
( Stokes_modes) p n
(mode_calcs.py) (Page 31/31) (May 24, 2024 14:29) title
border
grestore
(Printed by Michael Steel) rhead
(mode_calcs.py) (16/16) (Friday May 24, 2024) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
